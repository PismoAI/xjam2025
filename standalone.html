<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Block Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #toolbar {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
        }

        .tool-button {
            width: 40px;
            height: 40px;
            margin: 5px;
            background: #444;
            border: 2px solid #666;
            border-radius: 5px;
            cursor: pointer;
            color: white;
            font-size: 20px;
        }

        .tool-button:hover {
            background: #555;
        }

        .tool-button.selected {
            background: #666;
            border-color: #888;
        }

        #debug {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            text-shadow: 1px 1px 1px black;
        }
        
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            color: white;
            font-size: 24px;
            text-align: center;
            line-height: 20px;
            pointer-events: none;
            -webkit-user-select: none;
            user-select: none;
            text-shadow: 1px 1px 2px black;
        }
        
        #instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            font-family: monospace;
            border-radius: 5px;
            pointer-events: none;
        }
        
        #camera-mode {
            position: fixed;
            top: 10px;
            right: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }

        #block-selector {
            margin-top: 10px;
            width: 100%;
        }

        #blockType {
            width: 100%;
            padding: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid #666;
            border-radius: 4px;
            cursor: pointer;
        }

        #blockType option {
            background: rgba(40, 40, 40, 0.9);
            color: white;
            padding: 5px;
        }

        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        #multiplayer-ui {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            color: white;
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 1000;
        }

        #multiplayer-ui.connected {
            background: rgba(0, 100, 0, 0.7);
        }

        #multiplayer-ui.disconnected {
            background: rgba(100, 0, 0, 0.7);
        }

        #server-url {
            padding: 5px;
            border-radius: 3px;
            border: 1px solid #666;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            width: 250px;
        }

        #connect-btn {
            padding: 5px 15px;
            border-radius: 3px;
            border: none;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            transition: background 0.3s;
        }

        #connect-btn:hover {
            background: #45a049;
        }

        #connect-btn.disconnecting {
            background: #f44336;
        }

        #player-count {
            margin-left: 10px;
            font-family: monospace;
        }

        .player-list {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
            max-width: 200px;
            display: none;
        }

        .player-list.visible {
            display: block;
        }

        .player-list-item {
            padding: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .player-list-item:last-child {
            border-bottom: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="debug">
        <div>FPS: <span id="fps">0</span></div>
        <div>Position: <span id="position">0, 0, 0</span></div>
        <div>Chunk: <span id="chunk">0, 0</span></div>
    </div>
    <div id="toolbar">
        <div>Build Tools</div>
        <button class="tool-button" id="placeBlock" title="Place Block">üì¶</button>
        <button class="tool-button" id="deleteBlock" title="Delete Block">üóëÔ∏è</button>
        <button class="tool-button" id="cameraMode" title="Toggle Camera Mode (F)">üëÅÔ∏è</button>
        <div id="block-selector">
            <label for="blockType" class="visually-hidden">Select Block Type</label>
            <select id="blockType" aria-label="Select Block Type">
                <option value="stone">Stone</option>
                <option value="granite">Granite</option>
                <option value="diorite">Diorite</option>
                <option value="andesite">Andesite</option>
                <option value="grass">Grass</option>
                <option value="dirt">Dirt</option>
                <option value="coarse_dirt">Coarse Dirt</option>
                <option value="podzol">Podzol</option>
                <option value="sand">Sand</option>
                <option value="red_sand">Red Sand</option>
                <option value="gravel">Gravel</option>
                <option value="snow">Snow</option>
                <option value="sandstone">Sandstone</option>
                <option value="moss_stone">Moss Stone</option>
                <option value="clay">Clay</option>
            </select>
        </div>
    </div>

    <div id="instructions">
        <div>Controls:</div>
        <div>WASD - Move</div>
        <div>Space - Jump</div>
        <div>F - Toggle Camera Mode</div>
        <div>G - Launch Rocket (with gravity)</div>
        <div>H - Launch Straight Rocket</div>
        <div>J - Launch Mega Nuke</div>
        <div>K - Launch Total Nuke</div>
        <div>L - Launch Massive Nuke</div>
        <div>M - Launch House Construction Rocket</div>
        <div>V - Launch Construction Rocket</div>
        <div>B - Launch Large Construction Rocket</div>
        <div>Click - Place/Break Block</div>
    </div>

    <div id="multiplayer-ui">
        <input type="text" id="server-url" placeholder="ws://localhost:8080" value="ws://localhost:8080">
        <button id="connect-btn">Connect</button>
        <span id="player-count">Players: 0</span>
    </div>
    <div class="player-list">
        <div class="player-list-header">Players Online</div>
        <div id="player-list-content"></div>
    </div>

    <div id="build-presets" style="
        position: fixed;
        top: 100px;
        left: 20px;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        font-family: monospace;
    ">
        Build Presets:<br>
        1 - Construction Rocket (Small Build)<br>
        2 - Large Construction Rocket (Medium Build)<br>
        3 - Massive Construction Rocket (Large Build)<br>
        4 - Regular Rocket (Small Delete)<br>
        5 - Total Nuke (Medium Delete)<br>
        6 - Massive Nuke (Large Delete)<br>
        7 - House Construction<br>
        8 - Office Building<br>
        9 - SpaceX Rocket
    </div>

    <script>
        // Configuration
        const CONFIG = {
            GENERATION: {
                SEED: Math.random() * 1000000,
                SCALE: 256.0,             // Industry standard base scale
                HEIGHT_SCALE: 96.0,        // Dramatic terrain variation
                OCTAVES: 4,               // Balanced for performance and detail
                PERSISTENCE: 0.5,         // Natural look
                LACUNARITY: 2.0,         // Standard lacunarity
                BIOME_SCALE: 512.0,      // Large scale for gradual biome transitions
                FEATURES: {
                    SNOW_HEIGHT: 400,
                    DESERT_DEPTH: 32,
                    MOUNTAIN_THRESHOLD: 0.8
                },
                NOISE: {
                    BASE_FREQUENCY: 1.0,
                    DETAIL_SCALE: 32.0,
                    ROUGHNESS_SCALE: 64.0,
                    EROSION_SCALE: 128.0
                },
                CLIMATE: {
                    TEMPERATURE_SCALE: 800.0,
                    HUMIDITY_SCALE: 600.0,
                    VARIATION_SCALE: 300.0,
                    BLEND_SCALE: 200.0
                },
                BIOMES: {
                    TRANSITION_SIZE: 0.15,
                    HEIGHT_INFLUENCE: 0.4,
                    TEMPERATURE_WEIGHT: 0.6,
                    HUMIDITY_WEIGHT: 0.4
                }
            },
            BLOCKS: {
                TYPES: {
                    AIR: 0,
                    STONE: 1,
                    GRANITE: 2,
                    DIORITE: 3,
                    ANDESITE: 4,
                    GRASS: 5,
                    DIRT: 6,
                    COARSE_DIRT: 7,
                    PODZOL: 8,
                    SAND: 9,
                    RED_SAND: 10,
                    GRAVEL: 11,
                    SNOW: 12,
                    SANDSTONE: 13,
                    MOSS_STONE: 14,
                    CLAY: 15,
                    WOOD: 16,
                    LEAVES: 17,
                    WATER: 18,
                    LAVA: 19,
                    CLOUD: 20
                },
                COLORS: {
                    STONE: new THREE.Color(0x707070),
                    GRANITE: new THREE.Color(0x956855),
                    DIORITE: new THREE.Color(0xE0E0E0),
                    ANDESITE: new THREE.Color(0x8A8A8A),
                    GRASS: new THREE.Color(0x567D46),
                    DIRT: new THREE.Color(0x8B4513),
                    COARSE_DIRT: new THREE.Color(0x8B5A2B),
                    PODZOL: new THREE.Color(0x6A4423),
                    SAND: new THREE.Color(0xDCD5A0),
                    RED_SAND: new THREE.Color(0xBC7642),
                    GRAVEL: new THREE.Color(0x808080),
                    SNOW: new THREE.Color(0xFFFFFF),
                    SANDSTONE: new THREE.Color(0xDCD293),
                    MOSS_STONE: new THREE.Color(0x6B7358),
                    CLAY: new THREE.Color(0x9BA3B2),
                    WOOD: new THREE.Color(0x8B4513),
                    LEAVES: new THREE.Color(0x2D5A27),
                    WATER: new THREE.Color(0x3F7FE8).multiplyScalar(0.7),
                    LAVA: new THREE.Color(0xFF4400),
                    CLOUD: new THREE.Color(0xFFFFFF).multiplyScalar(0.9)
                }
            },
            CHUNK: {
                SIZE: 16,                // Standard chunk size
                HEIGHT: 256,             // Standard world height
                RENDER_DISTANCE: 6,      // Conservative render distance for high FPS
                INITIAL_LOAD_RADIUS: 5,  // Load most visible area
                EDGE_LOAD_DISTANCE: 1    // Minimal edge loading
            },
            CHUNK_PRELOAD_BATCH: 4,      // Small batches for smooth loading
            CHUNK_LOAD_RADIUS: 6,        // Match render distance
            CHUNK_UNLOAD_RADIUS: 8,      // Small buffer
            CHUNK_CACHE_SIZE: 256,       // Conservative cache
            CHUNK_CACHE_CLEANUP_INTERVAL: 60000,  // More frequent cleanup
            CHUNK_IMMEDIATE_LOADS: 8,    // Very conservative for smooth startup
            CHUNK_AGGRESSIVE_LOADING: false,  // Disable aggressive loading
            CHUNK_SAVE_GENERATED: true,
            CHUNK_LOAD_STRATEGY: 'SPIRAL_OUT'
        };

        // Add after existing CONFIG but before game code
        const INSTANCING = {
            enabled: false,  // Safe default
            maxInstances: CONFIG.CHUNK.SIZE * CONFIG.CHUNK.SIZE * 16,
            blockMeshes: new Map(),
            initialized: false
        };

        // Add InstancedBlockManager before game class
        class InstancedBlockManager {
            constructor(game) {
                this.game = game;
                this.blockMeshes = new Map();
                this.maxInstances = INSTANCING.maxInstances;
                this.initialized = false;
                this.fallbackMode = false;
            }

            init() {
                if (this.initialized) return;
                try {
                    // Initialize safely
                    this.setupInstancedMeshes();
                    this.initialized = true;
                    INSTANCING.initialized = true;
                } catch (e) {
                    console.warn('Instancing initialization failed, using fallback', e);
                    this.fallbackMode = true;
                }
            }

            setupInstancedMeshes() {
                Object.keys(CONFIG.BLOCKS.TYPES).forEach(blockType => {
                    if (blockType === 'AIR') return;
                    this.createBlockMesh(blockType);
                });
            }

            createBlockMesh(blockType) {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshLambertMaterial({
                    color: CONFIG.BLOCKS.COLORS[blockType]
                });
                
                const mesh = new THREE.InstancedMesh(
                    geometry,
                    material,
                    this.maxInstances
                );
                mesh.count = 0;  // Start with 0 instances
                
                this.blockMeshes.set(blockType, mesh);
                this.game.scene.add(mesh);
            }

            updateChunk(chunk) {
                if (this.fallbackMode) return false;
                
                try {
                    // Clear previous instances
                    this.blockMeshes.forEach(mesh => mesh.count = 0);
                    
                    // Update instance matrices
                    chunk.blocks.forEach((type, key) => {
                        if (type === CONFIG.BLOCKS.TYPES.AIR) return;
                        
                        const [x, y, z] = key.split(',').map(Number);
                        const worldX = chunk.x * CONFIG.CHUNK.SIZE + x;
                        const worldZ = chunk.z * CONFIG.CHUNK.SIZE + z;
                        
                        const mesh = this.blockMeshes.get(
                            Object.keys(CONFIG.BLOCKS.TYPES)[type]
                        );
                        if (!mesh) return;
                        
                        const matrix = new THREE.Matrix4()
                            .setPosition(worldX, y, worldZ);
                        mesh.setMatrixAt(mesh.count, matrix);
                        mesh.count++;
                    });
                    
                    // Update instance buffers
                    this.blockMeshes.forEach(mesh => {
                        mesh.instanceMatrix.needsUpdate = true;
                    });
                    
                    return true;
                } catch (e) {
                    console.warn('Chunk update failed, using fallback', e);
                    this.fallbackMode = true;
                    return false;
                }
            }
        }

        // Cube geometry constants
        const CUBE_VERTICES = [
            [0, 0, 0], // 0
            [1, 0, 0], // 1
            [1, 1, 0], // 2
            [0, 1, 0], // 3
            [0, 0, 1], // 4
            [1, 0, 1], // 5
            [1, 1, 1], // 6
            [0, 1, 1]  // 7
        ];

        const FACE_VERTICES = [
            [2, 1, 5, 6], // Right (+X)
            [0, 3, 7, 4], // Left (-X)
            [3, 2, 6, 7], // Top (+Y)
            [1, 0, 4, 5], // Bottom (-Y)
            [6, 5, 4, 7], // Front (+Z)
            [1, 2, 3, 0]  // Back (-Z)
        ];

        const FACE_NORMALS = [
            [1, 0, 0],  // Right
            [-1, 0, 0], // Left
            [0, 1, 0],  // Top
            [0, -1, 0], // Bottom
            [0, 0, 1],  // Front
            [0, 0, -1]  // Back
        ];

        // Noise generation for terrain
        class SimplexNoise {
            constructor(seed = Math.random()) {
                this.p = new Uint8Array(256);
                this.perm = new Uint8Array(512);
                this.permMod12 = new Uint8Array(512);
                
                for (let i = 0; i < 256; i++) this.p[i] = i;
                
                let random = this.mulberry32(seed);
                for (let i = 255; i > 0; i--) {
                    const r = Math.floor(random() * (i + 1));
                    [this.p[i], this.p[r]] = [this.p[r], this.p[i]];
                }
                
                for (let i = 0; i < 512; i++) {
                    this.perm[i] = this.p[i & 255];
                    this.permMod12[i] = this.perm[i] % 12;
                }
            }
            
            mulberry32(a) {
                return function() {
                    a |= 0;
                    a = a + 0x6D2B79F5 | 0;
                    var t = Math.imul(a ^ a >>> 15, 1 | a);
                    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
                    return ((t ^ t >>> 14) >>> 0) / 4294967296;
                };
            }

            noise2D(xin, yin) {
                const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
                const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
                
                let n0 = 0, n1 = 0, n2 = 0;
                
                let s = (xin + yin) * F2;
                let i = Math.floor(xin + s);
                let j = Math.floor(yin + s);
                let t = (i + j) * G2;
                
                let X0 = i - t;
                let Y0 = j - t;
                let x0 = xin - X0;
                let y0 = yin - Y0;
                
                let i1 = x0 > y0 ? 1 : 0;
                let j1 = x0 > y0 ? 0 : 1;
                
                let x1 = x0 - i1 + G2;
                let y1 = y0 - j1 + G2;
                let x2 = x0 - 1.0 + 2.0 * G2;
                let y2 = y0 - 1.0 + 2.0 * G2;
                
                let ii = i & 255;
                let jj = j & 255;
                
                let t0 = 0.5 - x0 * x0 - y0 * y0;
                if (t0 >= 0) {
                    t0 *= t0;
                    let gi0 = this.permMod12[ii + this.perm[jj]];
                    n0 = t0 * t0 * this.dot(gi0, x0, y0);
                }
                
                let t1 = 0.5 - x1 * x1 - y1 * y1;
                if (t1 >= 0) {
                    t1 *= t1;
                    let gi1 = this.permMod12[ii + i1 + this.perm[jj + j1]];
                    n1 = t1 * t1 * this.dot(gi1, x1, y1);
                }
                
                let t2 = 0.5 - x2 * x2 - y2 * y2;
                if (t2 >= 0) {
                    t2 *= t2;
                    let gi2 = this.permMod12[ii + 1 + this.perm[jj + 1]];
                    n2 = t2 * t2 * this.dot(gi2, x2, y2);
                }
                
                return 70.0 * (n0 + n1 + n2);
            }
            
            dot(gi, x, y) {
                return x * (gi & 1 ? 1 : -1) + y * (gi & 2 ? 1 : -1);
            }
        }

        // Terrain Generator
        class TerrainGenerator {
            constructor() {
                this.noise = new SimplexNoise(CONFIG.GENERATION.SEED);
                this.variationNoise = new SimplexNoise(CONFIG.GENERATION.SEED + 1);
                this.detailNoise = new SimplexNoise(CONFIG.GENERATION.SEED + 2);
                this.stoneTypeNoise = new SimplexNoise(CONFIG.GENERATION.SEED + 3);
                this.biomeBlendNoise = new SimplexNoise(CONFIG.GENERATION.SEED + 4);
                this.erosionNoise = new SimplexNoise(CONFIG.GENERATION.SEED + 5);
                this.roughnessNoise = new SimplexNoise(CONFIG.GENERATION.SEED + 6);
                this.temperatureNoise = new SimplexNoise(CONFIG.GENERATION.SEED + 7);
                this.humidityNoise = new SimplexNoise(CONFIG.GENERATION.SEED + 8);
                this.slopeNoise = new SimplexNoise(CONFIG.GENERATION.SEED + 9);
                this.largeHillNoise = new SimplexNoise(CONFIG.GENERATION.SEED + 10);
                
                // Initialize caches
                this.noiseCache = new Map();
                this.biomeCache = new Map();
                this.maxCacheSize = 10000;
                
                // Constants for terrain generation
                this.SCALE = 400.0;            // Base scale for terrain variation
                this.BIOME_SCALE = 800.0;      // Biome transition scale
                this.DETAIL_SCALE = 50.0;      // Detail variation scale
                this.OCTAVES = 4;              // Number of noise octaves
                this.PERSISTENCE = 0.6;        // How much each octave contributes
                this.LACUNARITY = 2.2;         // How frequency increases each octave
                
                // Terrain height constraints
                this.MIN_HEIGHT = 32;          // Minimum terrain height
                this.MAX_HEIGHT = 96;          // Maximum terrain height
                this.BASE_HEIGHT = 48;         // Base terrain height
                this.HEIGHT_VARIATION = 24;    // How much height can vary
                
                // Large hill parameters
                this.LARGE_HILL_SCALE = 800.0; // Scale for large hill noise
                this.LARGE_HILL_THRESHOLD = 0.9; // Threshold for large hill generation (10% chance)
                this.LARGE_HILL_FACTOR = 2.0;  // Height multiplier for large hills
                
                // Terrain shaping
                this.SMOOTH_RADIUS = 1;        // Terrain smoothing radius
                this.DETAIL_AMPLITUDE = 3.0;   // Detail variation strength
                this.VALLEY_SCALE = 0.7;       // How deep valleys can be
            }

            // Get base height without constraints
            getBaseHeight(x, z) {
                const key = `base_${x},${z}`;
                if (this.noiseCache.has(key)) {
                    return this.noiseCache.get(key);
                }

                let baseHeight = 0;
                let amplitude = 1;
                let frequency = 1.0;
                let normalization = 0;

                // Calculate base terrain using FBM
                for (let o = 0; o < this.OCTAVES; o++) {
                    const sampleX = x * frequency / this.SCALE;
                    const sampleZ = z * frequency / this.SCALE;
                    
                    const noiseValue = this.noise.noise2D(sampleX, sampleZ);
                    baseHeight += noiseValue * amplitude;
                    normalization += amplitude;
                    
                    amplitude *= this.PERSISTENCE;
                    frequency *= this.LACUNARITY;
                }
                
                baseHeight = (baseHeight / normalization) * 96.0;

                // Check for large hill generation
                const largeHillValue = this.largeHillNoise.noise2D(x / this.LARGE_HILL_SCALE, z / this.LARGE_HILL_SCALE);
                const normalizedHillValue = (largeHillValue + 1) * 0.5;

                if (normalizedHillValue > this.LARGE_HILL_THRESHOLD) {
                    // Calculate influence factor (smooth transition)
                    const influence = (normalizedHillValue - this.LARGE_HILL_THRESHOLD) / (1 - this.LARGE_HILL_THRESHOLD);
                    const heightIncrease = baseHeight * (this.LARGE_HILL_FACTOR - 1) * influence;
                    
                    // Apply smooth falloff for hill edges
                    const edgeFalloff = this.calculateHillEdgeFalloff(x, z, normalizedHillValue);
                    baseHeight += heightIncrease * edgeFalloff;
                }
                
                // Cache the result
                if (this.noiseCache.size >= this.maxCacheSize) {
                    const oldestKey = this.noiseCache.keys().next().value;
                    this.noiseCache.delete(oldestKey);
                }
                this.noiseCache.set(key, baseHeight);
                
                return baseHeight;
            }

            calculateHillEdgeFalloff(x, z, centerValue) {
                // Sample surrounding points to create smooth transitions
                const sampleDistance = 32; // Distance to check for transitions
                let totalInfluence = 0;
                let samples = 0;

                for (let dx = -1; dx <= 1; dx++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        if (dx === 0 && dz === 0) continue;

                        const sampleX = x + dx * sampleDistance;
                        const sampleZ = z + dz * sampleDistance;
                        
                        const sampleValue = (this.largeHillNoise.noise2D(
                            sampleX / this.LARGE_HILL_SCALE, 
                            sampleZ / this.LARGE_HILL_SCALE
                        ) + 1) * 0.5;

                        if (sampleValue > this.LARGE_HILL_THRESHOLD) {
                            totalInfluence += 1;
                        }
                        samples++;
                    }
                }

                // Calculate falloff based on neighboring samples
                const neighborInfluence = totalInfluence / samples;
                return Math.min(1, (neighborInfluence + (centerValue > this.LARGE_HILL_THRESHOLD ? 1 : 0)) / 2);
            }

            // Calculate terrain slope at a point
            calculateSlope(x, z) {
                const spacing = 1.0; // Sample spacing
                const h = this.getBaseHeight(x, z);
                const hx = this.getBaseHeight(x + spacing, z);
                const hz = this.getBaseHeight(x, z + spacing);
                
                const slopeX = (hx - h) / spacing;
                const slopeZ = (hz - h) / spacing;
                
                return Math.sqrt(slopeX * slopeX + slopeZ * slopeZ);
            }

            // Apply Hermite interpolation for smooth transitions
            smoothHeight(x, z, baseHeight) {
                let totalWeight = 0;
                let smoothedHeight = 0;
                
                // Sample points in a radius
                for (let dx = -this.SMOOTH_RADIUS; dx <= this.SMOOTH_RADIUS; dx++) {
                    for (let dz = -this.SMOOTH_RADIUS; dz <= this.SMOOTH_RADIUS; dz++) {
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        if (distance > this.SMOOTH_RADIUS) continue;
                        
                        // Hermite weight calculation
                        const weight = 1 - (distance / this.SMOOTH_RADIUS);
                        const smoothWeight = weight * weight * (3 - 2 * weight); // Hermite interpolation
                        
                        const sampleHeight = this.getBaseHeight(x + dx, z + dz);
                        smoothedHeight += sampleHeight * smoothWeight;
                        totalWeight += smoothWeight;
                    }
                }
                
                return smoothedHeight / totalWeight;
            }

            // Add micro-detail variation
            addTerrainDetail(x, z, baseHeight) {
                const detailX = x / this.DETAIL_SCALE;
                const detailZ = z / this.DETAIL_SCALE;
                
                // Multi-layer detail
                const detail1 = this.detailNoise.noise2D(detailX, detailZ) * 0.5;
                const detail2 = this.detailNoise.noise2D(detailX * 2, detailZ * 2) * 0.25;
                const detail3 = this.detailNoise.noise2D(detailX * 4, detailZ * 4) * 0.125;
                
                const combinedDetail = (detail1 + detail2 + detail3) * this.DETAIL_AMPLITUDE;
                
                // Scale detail based on slope
                const slope = this.calculateSlope(x, z);
                const detailScale = Math.max(0, 1 - (slope / this.MAX_SLOPE));
                
                return baseHeight + (combinedDetail * detailScale);
            }

            getHeight(x, z) {
                let amplitude = 1;
                let frequency = 1;
                let noiseHeight = 0;
                let normalization = 0;

                // Generate main terrain using octaves (fractal noise)
                for (let o = 0; o < this.OCTAVES; o++) {
                    const sampleX = x * frequency / this.SCALE;
                    const sampleZ = z * frequency / this.SCALE;
                    
                    const noiseValue = this.noise.noise2D(sampleX, sampleZ);
                    noiseHeight += noiseValue * amplitude;
                    
                    normalization += amplitude;
                    amplitude *= this.PERSISTENCE;
                    frequency *= this.LACUNARITY;
                }

                // Normalize noise to 0-1 range
                noiseHeight = (noiseHeight / normalization) * 0.5 + 0.5;
                
                // Get biome influence
                const biomeX = x / this.BIOME_SCALE;
                const biomeZ = z / this.BIOME_SCALE;
                const biomeValue = (this.noise.noise2D(biomeX, biomeZ) + 1) * 0.5;
                
                const biomeType = this.getBiomeType(biomeValue);
                const biomeProps = this.getBiomeProperties(biomeType);
                
                // Calculate base height with new constraints
                let baseHeight = this.BASE_HEIGHT;
                baseHeight += (noiseHeight - 0.5) * this.HEIGHT_VARIATION;
                
                // Apply biome-specific modifications
                if (biomeType === 'MOUNTAINS') {
                    // Mountains can exceed normal height variation
                    baseHeight += Math.pow(noiseHeight, 2) * biomeProps.heightVariation;
                } else {
                    // Valleys are limited by VALLEY_SCALE
                    const valleyDepth = (0.5 - noiseHeight) * this.HEIGHT_VARIATION * this.VALLEY_SCALE;
                    baseHeight = Math.max(this.MIN_HEIGHT, baseHeight - Math.max(0, valleyDepth));
                }
                
                // Add small-scale detail
                const detailX = x / this.DETAIL_SCALE;
                const detailZ = z / this.DETAIL_SCALE;
                const detail = (this.detailNoise.noise2D(detailX, detailZ) + 1) * 0.5;
                baseHeight += (detail - 0.5) * this.DETAIL_AMPLITUDE;
                
                // Ensure height stays within global bounds
                const finalHeight = Math.max(this.MIN_HEIGHT, 
                                          Math.min(this.MAX_HEIGHT, Math.floor(baseHeight)));
                
                return {
                    height: finalHeight,
                    biomeType: biomeType,
                    variationValue: (this.variationNoise.noise2D(x / 20, z / 20) + 1) * 0.5
                };
            }

            findLowestNeighborHeight(x, z) {
                let lowestHeight = Infinity;
                
                // Check surrounding points
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        if (dx === 0 && dz === 0) continue;
                        
                        const neighborHeight = this.getBaseHeight(x + dx, z + dz);
                        lowestHeight = Math.min(lowestHeight, neighborHeight);
                    }
                }
                
                return lowestHeight;
            }

            getClimateData(x, z) {
                // Base temperature (latitude-based)
                let temperature = Math.cos(z / 800.0 * Math.PI) * 0.5 + 0.5;
                
                // Add temperature variation
                temperature += this.temperatureNoise.noise2D(x / 800.0, z / 800.0) * 0.2;
                
                // Get humidity with variation
                let humidity = (this.noise.noise2D(x / 600.0, z / 600.0) + 1) * 0.5;
                humidity += this.variationNoise.noise2D(x / 300.0, z / 300.0) * 0.1;
                
                // Clamp values
                temperature = Math.max(0, Math.min(1, temperature));
                humidity = Math.max(0, Math.min(1, humidity));

                return { temperature, humidity };
            }

            getBiomeType(x, z, height) {
                const cacheKey = `${x},${z},${height}`;
                if (this.biomeCache.has(cacheKey)) {
                    return this.biomeCache.get(cacheKey);
                }

                const climate = this.getClimateData(x, z);
                const { temperature, humidity } = climate;

                // Height influence on temperature
                const heightTemp = Math.max(0, 1 - (height / 400));
                const adjustedTemp = temperature * heightTemp;

                // Biome determination with smooth transitions
                let biomeType;
                if (height > 400) {
                    biomeType = 'TUNDRA';
                } else if (adjustedTemp < 0.2) {
                    biomeType = humidity > 0.5 ? 'TAIGA' : 'TUNDRA';
                } else if (adjustedTemp < 0.4) {
                    biomeType = humidity > 0.6 ? 'FOREST' : 'PLAINS';
                } else if (adjustedTemp < 0.7) {
                    biomeType = humidity > 0.6 ? 'JUNGLE' : 'PLAINS';
                } else {
                    biomeType = humidity < 0.2 ? 'DESERT' : 'SAVANNA';
                }

                // Special case for mountains - lowered threshold and added noise influence
                const mountainNoise = this.noise.noise2D(x / 200, z / 200);
                if (height > 70 + mountainNoise * 10) {
                    biomeType = 'MOUNTAINS';
                }

                // Cache the result
                if (this.biomeCache.size >= this.maxCacheSize) {
                    const oldestKey = this.biomeCache.keys().next().value;
                    this.biomeCache.delete(oldestKey);
                }
                this.biomeCache.set(cacheKey, biomeType);

                return biomeType;
            }

            getBiomeProperties(biomeType) {
                const properties = {
                    TUNDRA: {
                        baseHeight: 60,
                        heightVariation: 12,
                        temperature: 0.0,
                        humidity: 0.2,
                        surfaceBlock: 'SNOW',
                        subSurfaceBlock: 'DIRT'
                    },
                    TAIGA: {
                        baseHeight: 70,
                        heightVariation: 16,
                        temperature: 0.2,
                        humidity: 0.6,
                        surfaceBlock: 'GRASS',
                        subSurfaceBlock: 'DIRT'
                    },
                    PLAINS: {
                        baseHeight: 64,
                        heightVariation: 8,
                        temperature: 0.5,
                        humidity: 0.4,
                        surfaceBlock: 'GRASS',
                        subSurfaceBlock: 'DIRT'
                    },
                    FOREST: {
                        baseHeight: 68,
                        heightVariation: 14,
                        temperature: 0.6,
                        humidity: 0.7,
                        surfaceBlock: 'GRASS',
                        subSurfaceBlock: 'DIRT'
                    },
                    JUNGLE: {
                        baseHeight: 72,
                        heightVariation: 20,
                        temperature: 0.8,
                        humidity: 0.9,
                        surfaceBlock: 'GRASS',
                        subSurfaceBlock: 'DIRT'
                    },
                    DESERT: {
                        baseHeight: 62,
                        heightVariation: 10,
                        temperature: 0.9,
                        humidity: 0.1,
                        surfaceBlock: 'SAND',
                        subSurfaceBlock: 'SANDSTONE'
                    },
                    SAVANNA: {
                        baseHeight: 66,
                        heightVariation: 12,
                        temperature: 0.8,
                        humidity: 0.3,
                        surfaceBlock: 'GRASS',
                        subSurfaceBlock: 'DIRT'
                    },
                    MOUNTAINS: {
                        baseHeight: 90,
                        heightVariation: 40,
                        temperature: 0.3,
                        humidity: 0.5,
                        surfaceBlock: 'STONE',
                        subSurfaceBlock: 'STONE'
                    }
                };

                return properties[biomeType] || properties.PLAINS;
            }

            getSurfaceVariation(x, z, biomeType, height) {
                const biomeProps = this.getBiomeProperties(biomeType);
                const variationValue = this.variationNoise.noise2D(x / 30, z / 30);
                
                // Get base surface block from biome properties
                let surfaceBlock = biomeProps.surfaceBlock;
                
                // Add variations based on height and noise
                if (height > 100) {
                    // High elevation variations
                    if (variationValue > 0.6) {
                        surfaceBlock = 'SNOW';
                    } else if (variationValue > 0.3) {
                        surfaceBlock = 'STONE';
                    }
                } else if (biomeType === 'DESERT') {
                    // Desert variations
                    if (variationValue > 0.7) {
                        surfaceBlock = 'RED_SAND';
                    }
                } else if (biomeType === 'PLAINS' || biomeType === 'SAVANNA') {
                    // Plains/Savanna variations
                    if (variationValue > 0.8) {
                        surfaceBlock = 'COARSE_DIRT';
                    } else if (variationValue > 0.6) {
                        surfaceBlock = 'PODZOL';
                    }
                } else if (biomeType === 'MOUNTAINS') {
                    // Mountain variations
                    if (variationValue > 0.7) {
                        surfaceBlock = 'GRAVEL';
                    } else if (variationValue > 0.4) {
                        surfaceBlock = 'MOSS_STONE';
                    }
                }
                
                return surfaceBlock;
            }

            getCachedNoise(x, z, scale) {
                const key = `${x},${z},${scale}`;
                if (!this.noiseCache.has(key)) {
                    if (this.noiseCache.size >= this.maxCacheSize) {
                        const keys = Array.from(this.noiseCache.keys());
                        for (let i = 0; i < this.maxCacheSize * 0.2; i++) {
                            this.noiseCache.delete(keys[i]);
                        }
                    }
                    this.noiseCache.set(key, this.noise.noise2D(x, z));
                }
                return this.noiseCache.get(key);
            }

            getSubsurfaceBlock(biomeType, depth, variationValue, x, y, z) {
                const biomeProps = this.getBiomeProperties(biomeType);
                const subSurfaceBlock = biomeProps.subSurfaceBlock;
                
                // Get noise value for variation
                const noiseValue = this.variationNoise.noise2D(x / 20, z / 20);
                
                // Special cases based on biome and depth
                if (biomeType === 'DESERT') {
                    if (depth === 1 && noiseValue > 0.7) {
                        return 'RED_SAND';
                    }
                    return depth < 3 ? 'SAND' : 'SANDSTONE';
                }
                
                if (biomeType === 'MOUNTAINS') {
                    if (noiseValue > 0.8) {
                        return 'STONE';
                    }
                    return depth < 2 ? 'STONE' : this.getStoneType(x, y, z);
                }
                
                // For most biomes, transition from subsurface to stone
                if (depth > 3) {
                    return this.getStoneType(x, y, z);
                }
                
                // Add some variation to dirt layers
                if (noiseValue > 0.9) {
                    return 'COARSE_DIRT';
                }
                
                return subSurfaceBlock;
            }

            getStoneType(x, y, z) {
                const value = (this.stoneTypeNoise.noise2D(x / 30, z / 30) + 1) * 0.5;
                const yFactor = y / 50; // More variation at lower depths
                
                if (value < 0.3 + yFactor) return 'stone';
                if (value < 0.5 + yFactor) return 'granite';
                if (value < 0.7 + yFactor) return 'diorite';
                return 'andesite';
            }
        }

        // Chunk Management
        class Chunk {
            constructor(x, z, world) {
                this.x = x;
                this.z = z;
                this.world = world;
                this.scene = world.scene;
                this.blocks = new Uint8Array(CONFIG.CHUNK.SIZE * CONFIG.CHUNK.HEIGHT * CONFIG.CHUNK.SIZE);
                this.blockTypes = new Map();
                this.mesh = null;
                this.isDirty = true;
                this.isGenerated = false;
                this.boundingBoxes = [];
            }

            getBlockIndex(x, y, z) {
                return (y * CONFIG.CHUNK.SIZE * CONFIG.CHUNK.SIZE) + (z * CONFIG.CHUNK.SIZE) + x;
            }

            getHighestBlock(x, z) {
                for (let y = CONFIG.CHUNK.HEIGHT - 1; y >= 0; y--) {
                    if (this.getBlock(x, y, z) !== 0) {
                        return y;
                    }
                }
                return -1;
            }

            setBlock(x, y, z, type) {
                if (x < 0 || x >= CONFIG.CHUNK.SIZE || y < 0 || y >= CONFIG.CHUNK.HEIGHT || z < 0 || z >= CONFIG.CHUNK.SIZE) {
                    return;
                }
                
                const index = this.getBlockIndex(x, y, z);
                const blockId = type === null ? 0 : (typeof type === 'number' ? type : CONFIG.BLOCKS.TYPES[type]);
                this.blocks[index] = blockId;
                
                // Update bounding box
                const worldX = this.x * CONFIG.CHUNK.SIZE + x;
                const worldZ = this.z * CONFIG.CHUNK.SIZE + z;
                
                if (blockId !== 0) {
                    const box = new THREE.Box3(
                        new THREE.Vector3(worldX, y, worldZ),
                        new THREE.Vector3(worldX + 1, y + 1, worldZ + 1)
                    );
                    this.boundingBoxes[index] = box;
                } else {
                    this.boundingBoxes[index] = null;
                }
                
                this.isDirty = true;
            }

            getBlock(x, y, z) {
                if (x < 0 || x >= CONFIG.CHUNK.SIZE || y < 0 || y >= CONFIG.CHUNK.HEIGHT || z < 0 || z >= CONFIG.CHUNK.SIZE) {
                    return null;
                }
                const index = this.getBlockIndex(x, y, z);
                return this.blocks[index];
            }

            getBlocksInRegion(min, max) {
                const boxes = [];
                const minX = Math.floor(Math.max(0, min.x - this.x * CONFIG.CHUNK.SIZE));
                const maxX = Math.ceil(Math.min(CONFIG.CHUNK.SIZE, max.x - this.x * CONFIG.CHUNK.SIZE));
                const minY = Math.floor(Math.max(0, min.y));
                const maxY = Math.ceil(Math.min(CONFIG.CHUNK.HEIGHT, max.y));
                const minZ = Math.floor(Math.max(0, min.z - this.z * CONFIG.CHUNK.SIZE));
                const maxZ = Math.ceil(Math.min(CONFIG.CHUNK.SIZE, max.z - this.z * CONFIG.CHUNK.SIZE));

                for (let y = minY; y < maxY; y++) {
                    for (let z = minZ; z < maxZ; z++) {
                        for (let x = minX; x < maxX; x++) {
                            const index = this.getBlockIndex(x, y, z);
                            if (this.blocks[index] !== 0) {
                                const worldX = this.x * CONFIG.CHUNK.SIZE + x;
                                const worldZ = this.z * CONFIG.CHUNK.SIZE + z;
                                const box = new THREE.Box3(
                                    new THREE.Vector3(worldX, y, worldZ),
                                    new THREE.Vector3(worldX + 1, y + 1, worldZ + 1)
                                );
                                boxes.push(box);
                            }
                        }
                    }
                }
                return boxes;
            }

            generate() {
                this.blocks = new Uint8Array(CONFIG.CHUNK.SIZE * CONFIG.CHUNK.HEIGHT * CONFIG.CHUNK.SIZE);
                this.boundingBoxes = new Array(CONFIG.CHUNK.SIZE * CONFIG.CHUNK.HEIGHT * CONFIG.CHUNK.SIZE);

                // Generate terrain first
                for (let x = 0; x < CONFIG.CHUNK.SIZE; x++) {
                    for (let z = 0; z < CONFIG.CHUNK.SIZE; z++) {
                        const worldX = this.x * CONFIG.CHUNK.SIZE + x;
                        const worldZ = this.z * CONFIG.CHUNK.SIZE + z;
                        const heightData = this.world.generator.getHeight(worldX, worldZ);
                        const height = heightData.height;
                        const biomeType = heightData.biomeType;
                        const variationValue = heightData.variationValue;

                        // Fill blocks from bottom to height
                        for (let y = 0; y < height; y++) {
                            let blockType;
                            if (y === height - 1) {
                                // Surface block based on biome
                                blockType = this.world.generator.getSurfaceVariation(worldX, worldZ, biomeType, height);
                            } else if (y > height - 5) {
                                // Subsurface layers (4 blocks deep)
                                blockType = this.world.generator.getSubsurfaceBlock(biomeType, height - y, variationValue, worldX, y, worldZ);
                            } else {
                                // Deep underground
                                blockType = this.world.generator.getStoneType(worldX, y, worldZ);
                            }
                            this.setBlock(x, y, z, CONFIG.BLOCKS.TYPES[blockType.toUpperCase()]);
                        }

                        // Add bedrock at y=0
                        this.setBlock(x, 0, z, CONFIG.BLOCKS.TYPES.STONE);
                    }
                }

                // Generate trees with 50% chance per chunk
                if (Math.random() < 0.5) {
                    // Try to place 1-3 trees in the chunk
                    const numTrees = Math.floor(Math.random() * 3) + 1;
                    for (let i = 0; i < numTrees; i++) {
                        // Random position within chunk
                        const treeX = Math.floor(Math.random() * CONFIG.CHUNK.SIZE);
                        const treeZ = Math.floor(Math.random() * CONFIG.CHUNK.SIZE);
                        
                        // Get the height at this position
                        const y = this.getHighestBlock(treeX, treeZ);
                        
                        // Only place tree if we're on a valid surface block
                        const surfaceBlock = this.getBlock(treeX, y, treeZ);
                        if (surfaceBlock === CONFIG.BLOCKS.TYPES.GRASS || 
                            surfaceBlock === CONFIG.BLOCKS.TYPES.DIRT) {
                            
                            // Tree height (6-9 blocks)
                            const treeHeight = Math.floor(Math.random() * 4) + 6;
                            
                            // Generate trunk with slight variations
                            for (let dy = 1; dy <= treeHeight; dy++) {
                                this.setBlock(treeX, y + dy, treeZ, CONFIG.BLOCKS.TYPES.WOOD);
                                // Add some trunk thickness near the bottom
                                if (dy <= 2 && Math.random() < 0.4) {
                                    const dx = Math.random() < 0.5 ? 1 : -1;
                                    const dz = Math.random() < 0.5 ? 1 : -1;
                                    if (treeX + dx >= 0 && treeX + dx < CONFIG.CHUNK.SIZE &&
                                        treeZ + dz >= 0 && treeZ + dz < CONFIG.CHUNK.SIZE) {
                                        this.setBlock(treeX + dx, y + dy, treeZ + dz, CONFIG.BLOCKS.TYPES.WOOD);
                                    }
                                }
                            }
                            
                            // Generate leaves in a more natural, layered pattern
                            const leafStart = treeHeight - 4;
                            const leafEnd = treeHeight + 1;
                            
                            // Create multiple layers of leaves
                            for (let dy = leafStart; dy <= leafEnd; dy++) {
                                // Radius varies by layer
                                const baseRadius = dy === leafEnd ? 1 : 
                                                 dy === leafStart ? 3 :
                                                 dy === treeHeight ? 2 : 3;
                                
                                for (let dx = -baseRadius; dx <= baseRadius; dx++) {
                                    for (let dz = -baseRadius; dz <= baseRadius; dz++) {
                                        // Skip if outside chunk bounds
                                        if (treeX + dx < 0 || treeX + dx >= CONFIG.CHUNK.SIZE ||
                                            treeZ + dz < 0 || treeZ + dz >= CONFIG.CHUNK.SIZE) {
                                            continue;
                                        }
                                        
                                        // Create organic shape by varying leaf placement
                                        const distance = Math.sqrt(dx * dx + dz * dz);
                                        const randomFactor = Math.random() * 0.5 + 0.5;
                                        
                                        if (distance <= baseRadius * randomFactor) {
                                            // Don't place leaves where the trunk is
                                            if (!(dx === 0 && dz === 0 && dy <= treeHeight)) {
                                                // Add some randomness to leaf placement
                                                if (Math.random() < 0.8) {
                                                    this.setBlock(treeX + dx, y + dy, treeZ + dz, CONFIG.BLOCKS.TYPES.LEAVES);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Generate house with 10% chance per chunk
                if (Math.random() < 0.1) {
                    // Find a suitable flat area for the house
                    let houseX = Math.floor(Math.random() * (CONFIG.CHUNK.SIZE - 8));
                    let houseZ = Math.floor(Math.random() * (CONFIG.CHUNK.SIZE - 8));
                    
                    // Get average height for house foundation
                    let totalHeight = 0;
                    let heightSamples = 0;
                    
                    // Sample heights in house area
                    for (let dx = 0; dx < 8; dx++) {
                        for (let dz = 0; dz < 8; dz++) {
                            if (houseX + dx < CONFIG.CHUNK.SIZE && houseZ + dz < CONFIG.CHUNK.SIZE) {
                                const height = this.getHighestBlock(houseX + dx, houseZ + dz);
                                if (height !== -1) {
                                    totalHeight += height;
                                    heightSamples++;
                                }
                            }
                        }
                    }
                    
                    if (heightSamples > 0) {
                        const avgHeight = Math.floor(totalHeight / heightSamples);
                        
                        // Create house foundation
                        for (let dx = 0; dx < 8; dx++) {
                            for (let dz = 0; dz < 8; dz++) {
                                if (houseX + dx < CONFIG.CHUNK.SIZE && houseZ + dz < CONFIG.CHUNK.SIZE) {
                                    // Level the ground and create foundation
                                    for (let y = avgHeight; y < avgHeight + 4; y++) {
                                        // Walls
                                        if (y === avgHeight) {
                                            this.setBlock(houseX + dx, y, houseZ + dz, CONFIG.BLOCKS.TYPES.STONE);
                                        } else if (dx === 0 || dx === 7 || dz === 0 || dz === 7) {
                                            this.setBlock(houseX + dx, y, houseZ + dz, CONFIG.BLOCKS.TYPES.STONE);
                                        } else {
                                            // Interior
                                            this.setBlock(houseX + dx, y, houseZ + dz, CONFIG.BLOCKS.TYPES.AIR);
                                        }
                                    }
                                }
                            }
                        }

                        // Add roof
                        for (let dx = -1; dx <= 8; dx++) {
                            for (let dz = -1; dz <= 8; dz++) {
                                if (houseX + dx >= 0 && houseX + dx < CONFIG.CHUNK.SIZE &&
                                    houseZ + dz >= 0 && houseZ + dz < CONFIG.CHUNK.SIZE) {
                                    this.setBlock(houseX + dx, avgHeight + 4, houseZ + dz, CONFIG.BLOCKS.TYPES.STONE);
                                }
                            }
                        }

                        // Add door
                        this.setBlock(houseX + 4, avgHeight + 1, houseZ, CONFIG.BLOCKS.TYPES.AIR);
                        this.setBlock(houseX + 4, avgHeight + 2, houseZ, CONFIG.BLOCKS.TYPES.AIR);

                        // Add windows
                        const windowPositions = [
                            [2, 0], [6, 0], // Front windows
                            [2, 7], [6, 7], // Back windows
                            [0, 2], [0, 6], // Left windows
                            [7, 2], [7, 6]  // Right windows
                        ];

                        for (const [wx, wz] of windowPositions) {
                            this.setBlock(houseX + wx, avgHeight + 2, houseZ + wz, CONFIG.BLOCKS.TYPES.AIR);
                        }

                        // Add chimney
                        for (let y = 0; y < 3; y++) {
                            this.setBlock(houseX + 1, avgHeight + 4 + y, houseZ + 1, CONFIG.BLOCKS.TYPES.STONE);
                        }

                        // Add interior walls for rooms
                        // Vertical wall
                        for (let dz = 1; dz < 7; dz++) {
                            for (let y = avgHeight + 1; y < avgHeight + 4; y++) {
                                this.setBlock(houseX + 4, y, houseZ + dz, CONFIG.BLOCKS.TYPES.STONE);
                            }
                        }
                        
                        // Horizontal wall
                        for (let dx = 1; dx < 4; dx++) {
                            for (let y = avgHeight + 1; y < avgHeight + 4; y++) {
                                this.setBlock(houseX + dx, y, houseZ + 3, CONFIG.BLOCKS.TYPES.STONE);
                            }
                        }

                        // Add doors for rooms
                        this.setBlock(houseX + 4, avgHeight + 1, houseZ + 2, CONFIG.BLOCKS.TYPES.AIR);
                        this.setBlock(houseX + 4, avgHeight + 2, houseZ + 2, CONFIG.BLOCKS.TYPES.AIR);
                        this.setBlock(houseX + 2, avgHeight + 1, houseZ + 3, CONFIG.BLOCKS.TYPES.AIR);
                        this.setBlock(houseX + 2, avgHeight + 2, houseZ + 3, CONFIG.BLOCKS.TYPES.AIR);
                    }
                }

                // Generate skyscraper with 3% chance per chunk
                if (Math.random() < 0.03) {
                    // Find a suitable flat area for the skyscraper
                    let buildingX = Math.floor(Math.random() * (CONFIG.CHUNK.SIZE - 10));
                    let buildingZ = Math.floor(Math.random() * (CONFIG.CHUNK.SIZE - 10));
                    
                    // Get average height for building foundation
                    let totalHeight = 0;
                    let heightSamples = 0;
                    
                    // Sample heights in building area
                    for (let dx = 0; dx < 10; dx++) {
                        for (let dz = 0; dz < 10; dz++) {
                            if (buildingX + dx < CONFIG.CHUNK.SIZE && buildingZ + dz < CONFIG.CHUNK.SIZE) {
                                const height = this.getHighestBlock(buildingX + dx, buildingZ + dz);
                                if (height !== -1) {
                                    totalHeight += height;
                                    heightSamples++;
                                }
                            }
                        }
                    }
                    
                    if (heightSamples > 0) {
                        const avgHeight = Math.floor(totalHeight / heightSamples);
                        const buildingHeight = 20 + Math.floor(Math.random() * 10); // 20-30 blocks tall
                        
                        // Create building foundation and main structure
                        for (let y = 0; y < buildingHeight; y++) {
                            for (let dx = 0; dx < 10; dx++) {
                                for (let dz = 0; dz < 10; dz++) {
                                    if (buildingX + dx < CONFIG.CHUNK.SIZE && buildingZ + dz < CONFIG.CHUNK.SIZE) {
                                        // Ground floor
                                        if (y === 0) {
                                            this.setBlock(buildingX + dx, avgHeight + y, buildingZ + dz, CONFIG.BLOCKS.TYPES.STONE);
                                        }
                                        // Walls
                                        else if (dx === 0 || dx === 9 || dz === 0 || dz === 9) {
                                            // Create windows every 3 blocks vertically, starting from y=2
                                            if (y > 1 && y % 3 === 2 && 
                                                ((dx === 0 && dz % 3 === 1) || 
                                                 (dx === 9 && dz % 3 === 1) ||
                                                 (dz === 0 && dx % 3 === 1) ||
                                                 (dz === 9 && dx % 3 === 1))) {
                                                this.setBlock(buildingX + dx, avgHeight + y, buildingZ + dz, CONFIG.BLOCKS.TYPES.AIR);
                                            } else {
                                                this.setBlock(buildingX + dx, avgHeight + y, buildingZ + dz, CONFIG.BLOCKS.TYPES.STONE);
                                            }
                                        }
                                        // Interior
                                        else {
                                            // Create floors every 4 blocks
                                            if (y % 4 === 0) {
                                                this.setBlock(buildingX + dx, avgHeight + y, buildingZ + dz, CONFIG.BLOCKS.TYPES.STONE);
                                            } else {
                                                this.setBlock(buildingX + dx, avgHeight + y, buildingZ + dz, CONFIG.BLOCKS.TYPES.AIR);
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        // Add entrance
                        this.setBlock(buildingX + 5, avgHeight + 1, buildingZ, CONFIG.BLOCKS.TYPES.AIR);
                        this.setBlock(buildingX + 5, avgHeight + 2, buildingZ, CONFIG.BLOCKS.TYPES.AIR);
                        this.setBlock(buildingX + 4, avgHeight + 1, buildingZ, CONFIG.BLOCKS.TYPES.AIR);
                        this.setBlock(buildingX + 4, avgHeight + 2, buildingZ, CONFIG.BLOCKS.TYPES.AIR);

                        // Add roof features
                        for (let dx = 1; dx < 9; dx++) {
                            for (let dz = 1; dz < 9; dz++) {
                                if (buildingX + dx < CONFIG.CHUNK.SIZE && buildingZ + dz < CONFIG.CHUNK.SIZE) {
                                    // Add roof border
                                    if (dx === 1 || dx === 8 || dz === 1 || dz === 8) {
                                        this.setBlock(buildingX + dx, avgHeight + buildingHeight, buildingZ + dz, CONFIG.BLOCKS.TYPES.STONE);
                                    }
                                }
                            }
                        }

                        // Add antenna/spire
                        for (let y = 0; y < 5; y++) {
                            if (buildingX + 5 < CONFIG.CHUNK.SIZE && buildingZ + 5 < CONFIG.CHUNK.SIZE) {
                                this.setBlock(buildingX + 5, avgHeight + buildingHeight + y, buildingZ + 5, CONFIG.BLOCKS.TYPES.STONE);
                            }
                        }

                        // Add corner pillars for architectural detail
                        for (let y = 0; y < buildingHeight; y++) {
                            const cornerPositions = [[1,1], [1,8], [8,1], [8,8]];
                            for (const [px, pz] of cornerPositions) {
                                if (buildingX + px < CONFIG.CHUNK.SIZE && buildingZ + pz < CONFIG.CHUNK.SIZE) {
                                    this.setBlock(buildingX + px, avgHeight + y, buildingZ + pz, CONFIG.BLOCKS.TYPES.STONE);
                                }
                            }
                        }
                    }
                }

                // Generate island with 2% chance per chunk
                if (Math.random() < 0.02) {
                    // Find center position for the island
                    let islandX = Math.floor(Math.random() * (CONFIG.CHUNK.SIZE - 12)) + 6;
                    let islandZ = Math.floor(Math.random() * (CONFIG.CHUNK.SIZE - 12)) + 6;
                    
                    // Get base height for water level
                    const baseY = this.getHighestBlock(islandX, islandZ);
                    if (baseY !== -1) {
                        const waterLevel = baseY + 2; // Water level slightly above terrain
                        
                        // Create water area (15x15 blocks)
                        for (let dx = -7; dx <= 7; dx++) {
                            for (let dz = -7; dz <= 7; dz++) {
                                if (islandX + dx >= 0 && islandX + dx < CONFIG.CHUNK.SIZE &&
                                    islandZ + dz >= 0 && islandZ + dz < CONFIG.CHUNK.SIZE) {
                                    
                                    // Create deep water (5 blocks deep)
                                    for (let dy = 0; dy < 5; dy++) {
                                        this.setBlock(islandX + dx, waterLevel - dy, islandZ + dz, CONFIG.BLOCKS.TYPES.WATER);
                                    }
                                    
                                    // Create island in the center
                                    const distanceFromCenter = Math.sqrt(dx * dx + dz * dz);
                                    if (distanceFromCenter < 4) { // Island radius of 4 blocks
                                        // Island height varies with distance from center
                                        const islandHeight = Math.floor(3 * (1 - distanceFromCenter / 4)) + 1;
                                        
                                        // Create island terrain
                                        for (let dy = -5; dy < islandHeight; dy++) {
                                            const blockType = dy === islandHeight - 1 ? 
                                                CONFIG.BLOCKS.TYPES.GRASS : // Top layer is grass
                                                CONFIG.BLOCKS.TYPES.DIRT;  // Rest is dirt
                                            this.setBlock(islandX + dx, waterLevel + dy, islandZ + dz, blockType);
                                        }
                                        
                                        // Add random vegetation on top (25% chance)
                                        if (distanceFromCenter < 3 && Math.random() < 0.25) {
                                            // 50% chance for small tree, 50% chance for tall grass
                                            if (Math.random() < 0.5) {
                                                // Small tree
                                                const treeHeight = 3 + Math.floor(Math.random() * 2);
                                                // Trunk
                                                for (let ty = 0; ty < treeHeight; ty++) {
                                                    this.setBlock(islandX + dx, waterLevel + islandHeight + ty, islandZ + dz, CONFIG.BLOCKS.TYPES.WOOD);
                                                }
                                                // Leaves
                                                for (let lx = -1; lx <= 1; lx++) {
                                                    for (let lz = -1; lz <= 1; lz++) {
                                                        for (let ly = treeHeight - 2; ly <= treeHeight; ly++) {
                                                            if (islandX + dx + lx >= 0 && islandX + dx + lx < CONFIG.CHUNK.SIZE &&
                                                                islandZ + dz + lz >= 0 && islandZ + dz + lz < CONFIG.CHUNK.SIZE) {
                                                                if (Math.random() < 0.7) {
                                                                    this.setBlock(islandX + dx + lx, waterLevel + islandHeight + ly, islandZ + dz + lz, CONFIG.BLOCKS.TYPES.LEAVES);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    // Create sandy beach around the island
                                    else if (distanceFromCenter < 5) {
                                        // Beach slopes down into water
                                        const beachHeight = Math.floor(2 * (1 - (distanceFromCenter - 4)));
                                        for (let dy = -5; dy < beachHeight; dy++) {
                                            this.setBlock(islandX + dx, waterLevel + dy, islandZ + dz, CONFIG.BLOCKS.TYPES.SAND);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Generate volcano with 1% chance per chunk
                if (Math.random() < 0.01) {
                    // Find center position for the volcano
                    let volcanoX = Math.floor(Math.random() * (CONFIG.CHUNK.SIZE - 8)) + 4;
                    let volcanoZ = Math.floor(Math.random() * (CONFIG.CHUNK.SIZE - 8)) + 4;
                    
                    // Get the height at this position
                    const y = this.getHighestBlock(volcanoX, volcanoZ);
                    
                    if (y !== -1) {
                        // Volcano height (15-20 blocks)
                        const volcanoHeight = 15 + Math.floor(Math.random() * 6);
                        
                        // Generate volcano from bottom to top
                        for (let dy = 0; dy <= volcanoHeight; dy++) {
                            // Radius decreases as height increases
                            const radius = Math.max(1, Math.floor(6 * (1 - dy / volcanoHeight)));
                            
                            for (let dx = -radius; dx <= radius; dx++) {
                                for (let dz = -radius; dz <= radius; dz++) {
                                    // Skip if outside chunk bounds
                                    if (volcanoX + dx < 0 || volcanoX + dx >= CONFIG.CHUNK.SIZE ||
                                        volcanoZ + dz < 0 || volcanoZ + dz >= CONFIG.CHUNK.SIZE) {
                                        continue;
                                    }
                                    
                                    // Create circular shape
                                    const distance = Math.sqrt(dx * dx + dz * dz);
                                    if (distance <= radius) {
                                        // Top 2 layers are lava
                                        if (dy >= volcanoHeight - 2) {
                                            this.setBlock(volcanoX + dx, y + dy, volcanoZ + dz, CONFIG.BLOCKS.TYPES.LAVA);
                                        } else {
                                            this.setBlock(volcanoX + dx, y + dy, volcanoZ + dz, CONFIG.BLOCKS.TYPES.STONE);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Generate clouds - each layer has independent 2% chance
                // Get the height range for this chunk based on player position
                const chunkMinY = 100; // Start clouds at Y=100
                const playerY = this.player ? this.player.position.y : 100;
                const chunkMaxY = playerY + 100; // Always generate 100 blocks above player with no upper limit
                
                // Generate regular clouds (every 5 blocks)
                for (let cloudY = chunkMinY; cloudY < chunkMaxY; cloudY += 5) {
                    if (Math.random() < 0.02) { // 2% chance for each layer
                        // Random position within chunk for this cloud layer
                        const cloudX = Math.floor(Math.random() * (CONFIG.CHUNK.SIZE - 8));
                        const cloudZ = Math.floor(Math.random() * (CONFIG.CHUNK.SIZE - 8));
                        
                        // Cloud size varies by height (pattern of 4,3,2 repeating)
                        const heightCycle = Math.floor((cloudY - chunkMinY) / 15) * 3; // Complete pattern every 15 blocks
                        const layerInPattern = Math.floor((cloudY - chunkMinY) / 5) % 3;
                        const cloudSize = 4 - layerInPattern;
                        
                        // Generate cloud shape
                        for (let dx = -cloudSize; dx <= cloudSize; dx++) {
                            for (let dz = -cloudSize; dz <= cloudSize; dz++) {
                                // Skip if outside chunk bounds
                                if (cloudX + dx < 0 || cloudX + dx >= CONFIG.CHUNK.SIZE ||
                                    cloudZ + dz < 0 || cloudZ + dz >= CONFIG.CHUNK.SIZE) {
                                    continue;
                                }
                                
                                // Create puffy cloud shape
                                const distance = Math.sqrt(dx * dx + dz * dz);
                                if (distance <= cloudSize) {
                                    // Add some randomness to make clouds less uniform
                                    if (Math.random() < 0.8) {
                                        // Vary cloud thickness (1-2 blocks)
                                        const thickness = Math.random() < 0.5 ? 1 : 2;
                                        for (let dy = 0; dy < thickness; dy++) {
                                            this.setBlock(cloudX + dx, cloudY + dy, cloudZ + dz, CONFIG.BLOCKS.TYPES.CLOUD);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Generate larger clouds (every 8 blocks)
                for (let cloudY = chunkMinY + 20; cloudY < chunkMaxY; cloudY += 8) {
                    if (Math.random() < 0.02) { // 2% chance for each layer
                        // Random position within chunk for this cloud layer
                        const cloudX = Math.floor(Math.random() * (CONFIG.CHUNK.SIZE - 16));
                        const cloudZ = Math.floor(Math.random() * (CONFIG.CHUNK.SIZE - 16));
                        
                        // Cloud size varies by height (pattern of 8,7,6 repeating)
                        const heightCycle = Math.floor((cloudY - (chunkMinY + 20)) / 24) * 3; // Complete pattern every 24 blocks
                        const layerInPattern = Math.floor((cloudY - (chunkMinY + 20)) / 8) % 3;
                        const cloudSize = 8 - layerInPattern;
                        
                        // For every third layer, make it 1.5 times larger
                        const finalSize = layerInPattern === 2 ? cloudSize * 1.5 : cloudSize;
                        
                        // Generate large cloud shape
                        for (let dx = -finalSize; dx <= finalSize; dx++) {
                            for (let dz = -finalSize; dz <= finalSize; dz++) {
                                // Skip if outside chunk bounds
                                if (cloudX + dx < 0 || cloudX + dx >= CONFIG.CHUNK.SIZE ||
                                    cloudZ + dz < 0 || cloudZ + dz >= CONFIG.CHUNK.SIZE) {
                                    continue;
                                }
                                
                                // Create puffy cloud shape
                                const distance = Math.sqrt(dx * dx + dz * dz);
                                if (distance <= finalSize) {
                                    // Add some randomness to make clouds less uniform
                                    if (Math.random() < 0.8) {
                                        // Vary cloud thickness (2-3 blocks for larger clouds)
                                        const thickness = Math.random() < 0.5 ? 2 : 3;
                                        for (let dy = 0; dy < thickness; dy++) {
                                            this.setBlock(cloudX + dx, cloudY + dy, cloudZ + dz, CONFIG.BLOCKS.TYPES.CLOUD);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Apply any stored modifications after terrain generation
                for (let x = 0; x < CONFIG.CHUNK.SIZE; x++) {
                    for (let y = 0; y < CONFIG.CHUNK.HEIGHT; y++) {
                        for (let z = 0; z < CONFIG.CHUNK.SIZE; z++) {
                            const key = `${this.x},${this.z},${x},${y},${z}`;
                            if (this.world.modifiedBlocks.has(key)) {
                                const blockType = this.world.modifiedBlocks.get(key);
                            this.setBlock(x, y, z, blockType);
                            }
                        }
                    }
                }

                this.isGenerated = true;
                this.isDirty = true;
            }

            rebuildMesh() {
                if (!this.isGenerated) return;

                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const colors = [];
                const indices = [];
                let vertexIndex = 0;

                // Define cube vertices properly
                const VERTICES = [
                    // Front face
                    { pos: [-0.5, -0.5,  0.5], normal: [ 0,  0,  1] },
                    { pos: [ 0.5, -0.5,  0.5], normal: [ 0,  0,  1] },
                    { pos: [ 0.5,  0.5,  0.5], normal: [ 0,  0,  1] },
                    { pos: [-0.5,  0.5,  0.5], normal: [ 0,  0,  1] },
                    // Back face
                    { pos: [-0.5, -0.5, -0.5], normal: [ 0,  0, -1] },
                    { pos: [-0.5,  0.5, -0.5], normal: [ 0,  0, -1] },
                    { pos: [ 0.5,  0.5, -0.5], normal: [ 0,  0, -1] },
                    { pos: [ 0.5, -0.5, -0.5], normal: [ 0,  0, -1] },
                    // Top face
                    { pos: [-0.5,  0.5, -0.5], normal: [ 0,  1,  0] },
                    { pos: [-0.5,  0.5,  0.5], normal: [ 0,  1,  0] },
                    { pos: [ 0.5,  0.5,  0.5], normal: [ 0,  1,  0] },
                    { pos: [ 0.5,  0.5, -0.5], normal: [ 0,  1,  0] },
                    // Bottom face
                    { pos: [-0.5, -0.5, -0.5], normal: [ 0, -1,  0] },
                    { pos: [ 0.5, -0.5, -0.5], normal: [ 0, -1,  0] },
                    { pos: [ 0.5, -0.5,  0.5], normal: [ 0, -1,  0] },
                    { pos: [-0.5, -0.5,  0.5], normal: [ 0, -1,  0] },
                    // Right face
                    { pos: [ 0.5, -0.5, -0.5], normal: [ 1,  0,  0] },
                    { pos: [ 0.5,  0.5, -0.5], normal: [ 1,  0,  0] },
                    { pos: [ 0.5,  0.5,  0.5], normal: [ 1,  0,  0] },
                    { pos: [ 0.5, -0.5,  0.5], normal: [ 1,  0,  0] },
                    // Left face
                    { pos: [-0.5, -0.5, -0.5], normal: [-1,  0,  0] },
                    { pos: [-0.5, -0.5,  0.5], normal: [-1,  0,  0] },
                    { pos: [-0.5,  0.5,  0.5], normal: [-1,  0,  0] },
                    { pos: [-0.5,  0.5, -0.5], normal: [-1,  0,  0] }
                ];

                // Define faces with correct winding order
                const FACES = [
                    [0, 1, 2, 0, 2, 3],    // Front
                    [4, 5, 6, 4, 6, 7],    // Back
                    [8, 9, 10, 8, 10, 11], // Top
                    [12, 13, 14, 12, 14, 15], // Bottom
                    [16, 17, 18, 16, 18, 19], // Right
                    [20, 21, 22, 20, 22, 23]  // Left
                ];

                // Helper function to check if a block face should be rendered
                const shouldRenderFace = (x, y, z, faceIndex) => {
                    const normal = VERTICES[faceIndex * 4].normal;
                    const nx = x + normal[0];
                    const ny = y + normal[1];
                    const nz = z + normal[2];

                    // Always show top faces for surface blocks
                    if (normal[1] === 1 && y === this.getHighestBlock(x, z)) {
                        return true;
                    }

                    // Never show bottom faces except for floating blocks
                    if (normal[1] === -1 && y > 0) {
                        const blockBelow = this.getBlock(x, y - 1, z);
                        if (blockBelow !== 0 && blockBelow !== null) {
                            return false;
                        }
                    }

                    // Check chunk boundaries
                    if (nx < 0 || nx >= CONFIG.CHUNK.SIZE ||
                        ny < 0 || ny >= CONFIG.CHUNK.HEIGHT ||
                        nz < 0 || nz >= CONFIG.CHUNK.SIZE) {
                        return true;
                    }

                    // Get neighbor block
                    const neighborBlock = this.getBlock(nx, ny, nz);
                    return neighborBlock === 0 || neighborBlock === null;
                };

                // Iterate through all blocks in the chunk
                for (let y = 0; y < CONFIG.CHUNK.HEIGHT; y++) {
                    for (let z = 0; z < CONFIG.CHUNK.SIZE; z++) {
                        for (let x = 0; x < CONFIG.CHUNK.SIZE; x++) {
                            const blockId = this.getBlock(x, y, z);
                            if (blockId === 0) continue;

                            // Get block color
                            const blockType = Object.keys(CONFIG.BLOCKS.TYPES).find(key => CONFIG.BLOCKS.TYPES[key] === blockId);
                            const blockColor = CONFIG.BLOCKS.COLORS[blockType];

                            // Process each face
                            for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
                                if (shouldRenderFace(x, y, z, faceIndex)) {
                                    // Add vertices for this face
                                    const faceVertices = VERTICES.slice(faceIndex * 4, (faceIndex + 1) * 4);
                                    const normal = faceVertices[0].normal;

                                    for (const vertex of faceVertices) {
                                        vertices.push(
                                            x + vertex.pos[0] + 0.5,
                                            y + vertex.pos[1] + 0.5,
                                            z + vertex.pos[2] + 0.5
                                        );

                                        // Calculate face shading
                                        let shade = 1.0;
                                        if (normal[1] === 1) shade = 1.0;     // Top face
                                        else if (normal[1] === -1) shade = 0.6; // Bottom face
                                        else shade = 0.8;                    // Side faces

                                        colors.push(
                                            blockColor.r * shade,
                                            blockColor.g * shade,
                                            blockColor.b * shade
                                        );
                                    }

                                    // Add indices for this face
                                    const face = FACES[faceIndex];
                                    for (const index of face) {
                                        indices.push(vertexIndex + (index % 4));
                                    }
                                    vertexIndex += 4;
                                }
                            }
                        }
                    }
                }

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();

                const material = new THREE.MeshStandardMaterial({
                    vertexColors: true,
                    side: THREE.FrontSide,
                    metalness: 0.0,
                    roughness: 1.0
                });

                if (this.mesh) {
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                    this.scene.remove(this.mesh);
                }

                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.set(
                    this.x * CONFIG.CHUNK.SIZE,
                    0,
                    this.z * CONFIG.CHUNK.SIZE
                );
                this.scene.add(this.mesh);
                this.isDirty = false;
            }

            getBlocksInSphere(center, radius) {
                const blocks = []
                const radiusSquared = radius * radius
                
                // Convert world position to chunk-local coordinates
                const localCenter = new THREE.Vector3(
                    center.x - this.x * CONFIG.CHUNK.SIZE,
                    center.y,
                    center.z - this.z * CONFIG.CHUNK.SIZE
                )

                // Optimize search space
                const minX = Math.max(0, Math.floor(localCenter.x - radius))
                const maxX = Math.min(CONFIG.CHUNK.SIZE, Math.ceil(localCenter.x + radius))
                const minY = Math.max(0, Math.floor(localCenter.y - radius))
                const maxY = Math.min(CONFIG.CHUNK.HEIGHT, Math.ceil(localCenter.y + radius))
                const minZ = Math.max(0, Math.floor(localCenter.z - radius))
                const maxZ = Math.min(CONFIG.CHUNK.SIZE, Math.ceil(localCenter.z + radius))

                for (let y = minY; y < maxY; y++) {
                    for (let z = minZ; z < maxZ; z++) {
                        for (let x = minX; x < maxX; x++) {
                            const worldX = x + this.x * CONFIG.CHUNK.SIZE
                            const worldZ = z + this.z * CONFIG.CHUNK.SIZE
                            
                            const dx = worldX - center.x
                            const dy = y - center.y
                            const dz = worldZ - center.z
                            
                            if (dx * dx + dy * dy + dz * dz <= radiusSquared) {
                                const block = this.getBlock(x, y, z)
                                if (block) {
                                    blocks.push({
                                        type: block,
                                        position: new THREE.Vector3(worldX, y, worldZ)
                                    })
                                }
                            }
                        }
                    }
                }
                
                return blocks
            }
        }

        // Add chunk caching system
        class ChunkCache {
            constructor() {
                this.cache = new Map();
                this.maxSize = 50;  // Maximum number of cached chunks
            }

            getKey(x, z) {
                return `${x},${z}`;
            }

            has(x, z) {
                return this.cache.has(this.getKey(x, z));
            }

            get(x, z) {
                return this.cache.get(this.getKey(x, z));
            }

            set(x, z, data) {
                if (this.cache.size >= this.maxSize) {
                    const oldestKey = this.cache.keys().next().value;
                    this.cache.delete(oldestKey);
                }
                this.cache.set(this.getKey(x, z), data);
            }

            clear() {
                this.cache.clear();
            }
        }

        // Enhance ChunkManager
        class ChunkManager {
            constructor(world) {
                this.chunks = new Map();
                this.loadQueue = [];
                this.maxConcurrentLoads = CONFIG.CHUNK_PRELOAD_BATCH;
                this.chunksGeneratedThisFrame = 0;
                this.world = world;
                this.scene = world.game.scene;
                this.dirty = new Set();
                this.loadingRadius = CONFIG.CHUNK_LOAD_RADIUS;
                this.unloadRadius = CONFIG.CHUNK_UNLOAD_RADIUS;
                this.lastLoadTime = 0;
                this.loadCooldown = 50;  // Reduced from 1000 to load chunks more frequently
                this.lastPlayerChunk = { x: 0, z: 0 };
                this.isGenerating = false;
                this.priorityQueue = [];
                this.loadingBounds = new Set();
                this.chunkCache = new Map();
                this.maxCacheSize = 100;  // Increased from 50 to cache more chunks
            }

            cacheChunk(chunk) {
                const key = this.getChunkKey(chunk.x, chunk.z);
                
                // Only cache if not already in cache
                if (!this.chunkCache.has(key)) {
                    // Remove oldest cache entry if at max size
                    if (this.chunkCache.size >= this.maxCacheSize) {
                        const oldestKey = this.chunkCache.keys().next().value;
                        this.chunkCache.delete(oldestKey);
                    }
                    
                    // Store minimal chunk data
                    this.chunkCache.set(key, {
                        blocks: chunk.blocks,
                        x: chunk.x,
                        z: chunk.z
                    });
                }
            }

            loadChunk(x, z) {
                const key = this.getChunkKey(x, z);
                
                // Check cache first
                if (this.chunkCache.has(key)) {
                    const cachedData = this.chunkCache.get(key);
                    const chunk = new Chunk(x, z, this.world);
                    chunk.blocks = cachedData.blocks;
                    chunk.isGenerated = true;
                    chunk.isDirty = true;
                    this.chunks.set(key, chunk);
                    this.markChunkDirty(x, z);
                    this.chunkCache.delete(key); // Remove from cache after loading
                } else {
                    // Generate new chunk if not in cache
                    const chunk = new Chunk(x, z, this.world);
                    this.chunks.set(key, chunk);
                    chunk.generate();
                    this.markChunkDirty(x, z);
                }
            }

            unloadDistantChunks(playerPosition) {
                const centerX = Math.floor(playerPosition.x / CONFIG.CHUNK.SIZE)
                const centerZ = Math.floor(playerPosition.z / CONFIG.CHUNK.SIZE)
                const maxDistance = this.loadingRadius + 2

                this.chunks.forEach((chunk, key) => {
                    const dx = chunk.x - centerX
                    const dz = chunk.z - centerZ
                    if (Math.max(Math.abs(dx), Math.abs(dz)) > maxDistance) {
                        this.unloadChunk(chunk.x, chunk.z)
                    }
                })
            }

            unloadChunk(x, z) {
                const key = this.getChunkKey(x, z);
                const chunk = this.chunks.get(key);
                if (chunk) {
                    // Cache the chunk before unloading
                    this.cacheChunk(chunk);
                    
                    if (chunk.mesh) {
                        const index = this.world.collidableMeshes.indexOf(chunk.mesh);
                        if (index !== -1) {
                            this.world.collidableMeshes.splice(index, 1);
                        }
                        this.scene.remove(chunk.mesh);
                        chunk.mesh.geometry.dispose();
                        chunk.mesh.material.dispose();
                    }
                    this.chunks.delete(key);
                }
            }

            getChunkKey(x, z) {
                return `${x},${z}`
            }

            getChunk(x, z) {
                return this.chunks.get(this.getChunkKey(x, z))
            }

            getChunksInRadius(position, radius) {
                const centerX = Math.floor(position.x / CONFIG.CHUNK.SIZE)
                const centerZ = Math.floor(position.z / CONFIG.CHUNK.SIZE)
                const chunks = []
                
                for (let x = -radius; x <= radius; x++) {
                    for (let z = -radius; z <= radius; z++) {
                        const chunk = this.getChunk(centerX + x, centerZ + z)
                        if (chunk) chunks.push(chunk)
                    }
                }
                return chunks
            }

            getBlocksInRadius(position, radius) {
                const chunks = this.getChunksInRadius(position, Math.ceil(radius / CONFIG.CHUNK.SIZE))
                return chunks.flatMap(chunk => chunk.getBlocksInSphere(position, radius))
            }

            queueChunkLoad(x, z, priority) {
                const key = this.getChunkKey(x, z)
                if (!this.chunks.has(key)) {
                    this.loadQueue.push({ x, z, priority })
                    this.loadQueue.sort((a, b) => b.priority - a.priority)
                }
            }

            markChunkDirty(x, z) {
                const key = this.getChunkKey(x, z)
                this.dirty.add(key)
            }

            update(playerPosition) {
                const now = performance.now();
                const chunkX = Math.floor(playerPosition.x / CONFIG.CHUNK.SIZE);
                const chunkZ = Math.floor(playerPosition.z / CONFIG.CHUNK.SIZE);

                // Only update queue if player has moved to new chunk or queue is empty
                if ((chunkX !== this.lastPlayerChunk.x || 
                    chunkZ !== this.lastPlayerChunk.z || 
                    this.loadQueue.length === 0) && !this.isGenerating) {
                    
                    // Get player's view direction for priority
                    const viewDir = new THREE.Vector3();
                    this.world.game.camera.getWorldDirection(viewDir);
                    const viewAngle = Math.atan2(viewDir.x, viewDir.z);

                // Clear old queue
                this.loadQueue = [];
                    this.priorityQueue = [];

                    // Collect chunks to load with priority data
                    for (let dx = -this.loadingRadius; dx <= this.loadingRadius; dx++) {
                        for (let dz = -this.loadingRadius; dz <= this.loadingRadius; dz++) {
                            const distance = Math.sqrt(dx * dx + dz * dz);
                            if (distance <= this.loadingRadius) {
                                const x = chunkX + dx;
                                const z = chunkZ + dz;
                                const key = this.getChunkKey(x, z);

                                // Only add if chunk doesn't exist and isn't being loaded
                                if (!this.chunks.has(key) && !this.loadingBounds.has(key)) {
                                    const chunkAngle = Math.atan2(dx, dz);
                                    let angleDiff = Math.abs(chunkAngle - viewAngle);
                                    angleDiff = Math.min(angleDiff, Math.PI * 2 - angleDiff);

                                    this.priorityQueue.push({
                                        x: x,
                                        z: z,
                                        distance: distance,
                                        angleFromView: angleDiff,
                                        priority: (this.loadingRadius - distance) + (Math.PI - angleDiff) / Math.PI
                                    });
                                }
                            }
                        }
                    }

                    // Sort by priority
                    this.priorityQueue.sort((a, b) => b.priority - a.priority);
                    
                    // Transfer to load queue
                    this.loadQueue = this.priorityQueue.map(item => ({
                        x: item.x,
                        z: item.z,
                        priority: item.priority
                    }));

                    this.lastPlayerChunk = { x: chunkX, z: chunkZ };
                }

                // Process single chunk with cooldown
                if (!this.isGenerating && now - this.lastLoadTime > this.loadCooldown && this.loadQueue.length > 0) {
                    const request = this.loadQueue.shift();
                    const key = this.getChunkKey(request.x, request.z);
                    
                    if (!this.chunks.has(key) && !this.loadingBounds.has(key)) {
                        this.isGenerating = true;
                        this.loadingBounds.add(key);
                        this.loadChunk(request.x, request.z);
                        this.lastLoadTime = now;
                        this.isGenerating = false;
                        this.loadingBounds.delete(key);
                    }
                }

                // Update dirty chunks
                for (const key of this.dirty) {
                    const chunk = this.chunks.get(key);
                    if (chunk) {
                        chunk.rebuildMesh();
                        if (chunk.mesh && !this.world.collidableMeshes.includes(chunk.mesh)) {
                            this.world.collidableMeshes.push(chunk.mesh);
                        }
                    }
                    this.dirty.delete(key);
                }

                // Handle unloading with buffer
                const unloadDistance = this.loadingRadius + 2;
                this.chunks.forEach((chunk, key) => {
                    const dx = chunk.x - chunkX;
                    const dz = chunk.z - chunkZ;
                    if (Math.max(Math.abs(dx), Math.abs(dz)) > unloadDistance) {
                        this.unloadChunk(chunk.x, chunk.z);
                    }
                });
            }

            updateLoadQueue(centerX, centerZ) {
                this.loadQueue = [];

                // Prioritize chunks in view direction
                const viewDir = new THREE.Vector3();
                this.world.game.camera.getWorldDirection(viewDir);
                
                for (let r = 0; r <= this.loadingRadius; r++) {
                    for (let dx = -r; dx <= r; dx++) {
                        for (let dz = -r; dz <= r; dz++) {
                            if (Math.abs(dx) === r || Math.abs(dz) === r) {
                                const x = centerX + dx;
                                const z = centerZ + dz;
                                
                                if (!this.getChunk(x, z)) {
                                    const distance = Math.max(Math.abs(dx), Math.abs(dz));
                                    const priority = this.loadingRadius - distance;
                                    
                                    // Increase priority for chunks in view direction
                                    const chunkDir = new THREE.Vector2(dx, dz).normalize();
                                    const viewDirXZ = new THREE.Vector2(viewDir.x, viewDir.z).normalize();
                                    const dotProduct = chunkDir.dot(viewDirXZ);
                                    
                                    const finalPriority = priority + (dotProduct > 0 ? dotProduct * 2 : 0);
                                    
                                    this.queueChunkLoad(x, z, finalPriority);
                                }
                            }
                        }
                    }
                }

                // Sort queue by priority
                this.loadQueue.sort((a, b) => b.priority - a.priority);
            }

            loadChunkFromCache(x, z, cachedData) {
                const chunk = new Chunk(x, z, this.world);
                chunk.blocks = cachedData.blocks;
                chunk.isGenerated = true;
                chunk.isDirty = true;
                this.chunks.set(this.getChunkKey(x, z), chunk);
                this.markChunkDirty(x, z);
            }
        }

        // World Management
        class World {
            constructor(game) {
                this.game = game;
                this.scene = game.scene;
                this.chunkManager = new ChunkManager(this);
                this.generator = new TerrainGenerator();
                this.collidableMeshes = [];
                this.modifiedBlocks = new Map(); // Store modified blocks across chunk reloads
            }

            getChunk(x, z) {
                return this.chunkManager.getChunk(x, z);
            }

            update(playerPosition) {
                this.chunkManager.update(playerPosition);
            }

            setBlock(position, type) {
                const chunkX = Math.floor(position.x / CONFIG.CHUNK.SIZE);
                const chunkZ = Math.floor(position.z / CONFIG.CHUNK.SIZE);
                
                const chunk = this.getChunk(chunkX, chunkZ);
                if (chunk) {
                    const localX = Math.floor(position.x) - chunkX * CONFIG.CHUNK.SIZE;
                    const localZ = Math.floor(position.z) - chunkZ * CONFIG.CHUNK.SIZE;
                    const y = Math.floor(position.y);
                    
                    // Store the modification in our Map
                    const key = `${chunkX},${chunkZ},${localX},${y},${localZ}`;
                    if (type === null) {
                        this.modifiedBlocks.set(key, 0); // Store air block
                    } else {
                        this.modifiedBlocks.set(key, type);
                    }
                    
                    chunk.setBlock(localX, y, localZ, type);
                    
                    // Mark affected chunks as dirty
                    this.chunkManager.markChunkDirty(chunkX, chunkZ);
                    
                    // Check and mark neighboring chunks if needed
                    if (localX === 0) this.chunkManager.markChunkDirty(chunkX - 1, chunkZ);
                    if (localX === CONFIG.CHUNK.SIZE - 1) this.chunkManager.markChunkDirty(chunkX + 1, chunkZ);
                    if (localZ === 0) this.chunkManager.markChunkDirty(chunkX, chunkZ - 1);
                    if (localZ === CONFIG.CHUNK.SIZE - 1) this.chunkManager.markChunkDirty(chunkX, chunkZ + 1);
                }
            }

            getBlocksInRadius(position, radius) {
                return this.chunkManager.getBlocksInRadius(position, radius);
            }
        }

        // Game class
        class Game {
            constructor() {
                console.log('Starting game initialization...');
                
                // Initialize core systems first
                this.setupRenderer();
                this.setupScene();
                this.setupCamera();
                this.setupLighting();
                this.setupWorld();
                this.setupControls();
                this.setupUI();
                
                // Initialize network manager
                this.networkManager = new NetworkManager(this);
                
                this.lastTime = performance.now();
                this.frameCount = 0;
                this.rockets = [];
                
                // Physics and collision properties
                this.gravity = -32.0;
                this.jumpSpeed = 10.0;
                this.moveSpeed = 5;
                this.playerHeight = 1.7;
                this.playerWidth = 0.5;
                this.isGrounded = false;
                this.velocity = new THREE.Vector3();
                this.euler = new THREE.Euler(0, 0, 0, 'YXZ');
                this.canJump = true;
                this.jumpCooldown = 50;
                this.lastJumpTime = 0;
                
                // Add jump mode properties
                this.limitedJumpMode = false; // Toggle for jump mode
                this.remainingJumps = 5;      // Counter for limited jumps
                
                // Add player mesh materials
                this.playerMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00ff00,
                    metalness: 0.5,
                    roughness: 0.5
                });
                this.otherPlayerMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    metalness: 0.5,
                    roughness: 0.5
                });
                this.playerMeshes = new Map();
                
                // Create player geometry
                this.playerGeometry = new THREE.BoxGeometry(0.6, 1.8, 0.6);
                
                // Setup multiplayer UI
                this.setupMultiplayerUI();
                
                this.animate();
                console.log('Game initialized successfully!');
            }

            setupRenderer() {
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('gameCanvas'),
                    antialias: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
            }

            setupCamera() {
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(10, 100, 10);
                this.camera.lookAt(0, 0, 0);
                this.playerHeight = 1.7;      // Slightly shorter (was 1.8)
                this.playerPosition = new THREE.Vector3(10, 100 - this.playerHeight, 10);
            }

            setupLighting() {
                // Add ambient light
                const ambientLight = new THREE.AmbientLight(0x404040);
                this.scene.add(ambientLight);

                // Add directional light (sun)
                const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
                sunLight.position.set(100, 100, 50);
                this.scene.add(sunLight);
            }

            setupWorld() {
                this.world = new World(this);
                this.collidableMeshes = this.world.collidableMeshes;
            }

            setupUI() {
                // Setup toolbar
                const toolbar = document.getElementById('toolbar');
                if (!toolbar) {
                    console.error('Toolbar element not found!');
                    return;
                }

                // Setup block selector
                this.setupBlockSelector();
                
                // Update tool buttons
                this.updateToolButtons();
            }

            setupBlockSelector() {
                const blockSelector = document.getElementById('block-selector');
                if (!blockSelector) {
                    console.error('Block selector not found!');
                    return;
                }

                const blockType = document.getElementById('blockType');
                if (blockType) {
                    blockType.addEventListener('change', (e) => {
                        console.log(`Selected block type: ${e.target.value}`);
                    });
                }
            }

            setupControls() {
                this.keys = {};
                this.mousePosition = new THREE.Vector2();
                this.raycaster = new THREE.Raycaster();
                this.mouseSensitivity = 0.002;
                this.moveSpeed = 5;
                this.playerHeight = 1.7;
                this.playerWidth = 0.5;
                this.isGrounded = false;
                this.velocity = new THREE.Vector3();
                this.euler = new THREE.Euler(0, 0, 0, 'YXZ');
                this.canJump = true;
                this.jumpCooldown = 50;
                this.lastJumpTime = 0;
                this.sprintToggled = false; // Initialize sprint toggle state

                // Gamepad support
                this.gamepadState = {
                    lastButtons: new Array(16).fill(false),
                    deadzone: 0.1,
                    lookSensitivity: 0.057,  // Reduced by 5% from 0.06
                    rightStickX: 0,
                    rightStickY: 0,
                    leftStickX: 0,
                    leftStickY: 0
                };

                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    
                    // Toggle jump mode with plus key
                    if (e.code === 'Equal' && e.shiftKey) { // '+' key (Shift + =)
                        this.limitedJumpMode = !this.limitedJumpMode;
                        this.remainingJumps = 5; // Reset jumps on toggle
                        console.log(this.limitedJumpMode ? 'Limited Jump Mode: ON (5 jumps)' : 'Unlimited Jump Mode: ON');
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });

                // Mouse look controls
                document.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === document.getElementById('gameCanvas')) {
                        this.euler.setFromQuaternion(this.camera.quaternion);
                        this.euler.y -= e.movementX * this.mouseSensitivity;
                        this.euler.x -= e.movementY * this.mouseSensitivity;
                        this.euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.euler.x));
                        this.camera.quaternion.setFromEuler(this.euler);
                    }
                });

                // Block interaction keys
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'KeyQ') {
                        this.selectedTool = 'delete';
                        this.updateToolButtons();
                        if (document.pointerLockElement === document.getElementById('gameCanvas')) {
                            this.handleBlockInteraction('delete');
                        }
                    }
                    if (e.code === 'KeyE') {
                    this.selectedTool = 'block';
                    this.updateToolButtons();
                        if (document.pointerLockElement === document.getElementById('gameCanvas')) {
                            this.handleBlockInteraction('block');
                        }
                    }
                    if (e.code === 'KeyG') {
                        if (document.pointerLockElement === document.getElementById('gameCanvas')) {
                            this.launchRocket();
                        }
                    }
                    if (e.code === 'KeyH') {
                        if (document.pointerLockElement === document.getElementById('gameCanvas')) {
                            this.launchNuke();
                        }
                    }
                    if (e.code === 'KeyI') {
                        if (document.pointerLockElement === document.getElementById('gameCanvas')) {
                            this.launchMassiveConstructionRocket();
                        }
                    }
                    if (e.code === 'KeyJ') {
                        if (document.pointerLockElement === document.getElementById('gameCanvas')) {
                            this.launchMegaNuke();
                        }
                    }
                    if (e.code === 'KeyK') {
                        if (document.pointerLockElement === document.getElementById('gameCanvas')) {
                            this.launchTotalNuke();
                        }
                    }
                    if (e.code === 'KeyL') {
                        if (document.pointerLockElement === document.getElementById('gameCanvas')) {
                            this.launchMassiveNuke();
                        }
                    }
                    if (e.code === 'KeyM') {
                        if (document.pointerLockElement === document.getElementById('gameCanvas')) {
                            this.launchHouseConstructionRocket();
                        }
                    }
                    if (e.code === 'KeyV') {
                        if (document.pointerLockElement === document.getElementById('gameCanvas')) {
                            this.launchConstructionRocket();
                        }
                    }
                    if (e.code === 'KeyB') {
                        if (document.pointerLockElement === document.getElementById('gameCanvas')) {
                            this.launchLargeConstructionRocket();
                        }
                    }
                    if (e.code === 'Digit0') {
                        if (document.pointerLockElement === document.getElementById('gameCanvas')) {
                            this.launchSuperMassiveConstructionRocket();
                        }
                    }
                    if (e.code === 'Digit9') {
                        if (document.pointerLockElement === document.getElementById('gameCanvas')) {
                            this.launchUltraMassiveConstructionRocket();
                        }
                    }
                    if (e.code === 'KeyN') {
                        if (document.pointerLockElement === document.getElementById('gameCanvas')) {
                            this.launchOfficeConstructionRocket();
                        }
                    }
                });

                // Start gamepad polling
                this.gamepadLoop();
            }

            updateToolButtons() {
                document.querySelectorAll('.tool-button').forEach(button => {
                    button.classList.remove('selected');
                });
                document.getElementById(this.selectedTool === 'block' ? 'placeBlock' : 'deleteBlock')
                    .classList.add('selected');
            }

            handleBlockInteraction(action) {
                if (!document.pointerLockElement) return;

                // Set up raycaster with a very far distance (effectively unlimited)
                this.raycaster.far = 1000; // Increase this value for longer range
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                const intersects = [];
                
                // Get nearby chunks
                const chunkX = Math.floor(this.camera.position.x / CONFIG.CHUNK.SIZE);
                const chunkZ = Math.floor(this.camera.position.z / CONFIG.CHUNK.SIZE);
                
                // Increase the chunk search radius for longer range
                const searchRadius = Math.ceil(this.raycaster.far / CONFIG.CHUNK.SIZE);
                
                // Check surrounding chunks in larger radius
                for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                    for (let dz = -searchRadius; dz <= searchRadius; dz++) {
                        const chunk = this.world.getChunk(chunkX + dx, chunkZ + dz);
                        if (chunk && chunk.mesh) {
                            const chunkIntersects = this.raycaster.intersectObject(chunk.mesh);
                            intersects.push(...chunkIntersects);
                        }
                    }
                }

                // Find nearest intersection
                const nearestIntersection = intersects.length > 0 ? 
                    intersects.reduce((nearest, current) => 
                        !nearest || current.distance < nearest.distance ? current : nearest
                    ) : null;

                if (nearestIntersection) {
                    const intersect = nearestIntersection;
                    const position = new THREE.Vector3();
                    const normal = intersect.face.normal.clone();
                    
                    // Transform the normal from local chunk space to world space
                    normal.applyQuaternion(intersect.object.quaternion);

                    if (action === 'block') {
                        // Place block at intersection point plus face normal
                        position.copy(intersect.point).add(normal.multiplyScalar(0.5));
                        const blockType = document.getElementById('blockType').value.toUpperCase();
                        this.world.setBlock(position, CONFIG.BLOCKS.TYPES[blockType]);
                    } else if (action === 'delete') {
                        // Delete block at intersection point minus a small offset in normal direction
                        position.copy(intersect.point).sub(normal.multiplyScalar(0.5));
                        this.world.setBlock(position, null);
                        
                        // Force chunk update
                        const chunkX = Math.floor(position.x / CONFIG.CHUNK.SIZE);
                        const chunkZ = Math.floor(position.z / CONFIG.CHUNK.SIZE);
                        const chunk = this.world.getChunk(chunkX, chunkZ);
                        if (chunk) {
                            chunk.isDirty = true;
                        }
                    }
                }
            }

            createPlayerMesh(playerId, material) {
                const mesh = new THREE.Mesh(this.playerGeometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.scene.add(mesh);
                this.playerMeshes.set(playerId, mesh);
                return mesh;
            }

            updatePlayerMeshes() {
                // Update other players
                this.networkManager.players.forEach((player, playerId) => {
                    let mesh = this.playerMeshes.get(playerId);
                    if (!mesh) {
                        mesh = this.createPlayerMesh(playerId, this.otherPlayerMaterial);
                    }
                    mesh.position.copy(player.position);
                    mesh.rotation.copy(player.rotation);
                });

                // Remove disconnected players
                this.playerMeshes.forEach((mesh, playerId) => {
                    if (!this.networkManager.players.has(playerId)) {
                        this.scene.remove(mesh);
                        this.playerMeshes.delete(playerId);
                    }
                });
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const now = performance.now();
                const delta = (now - this.lastTime) / 1000;
                this.lastTime = now;
                this.frameCount++;

                // Update FPS counter
                document.getElementById('fps').textContent = Math.round(1 / delta);

                // Handle keyboard input
                this.handleInput(delta);

                // Update network state
                if (this.networkManager) {
                    this.networkManager.update();
                    this.updatePlayerMeshes();
                }

                // Update world
                this.world.update(this.camera.position);
                
                // Update rockets
                if (this.rockets) {
                    this.updateRockets(delta);
                }

                // Render scene
                this.renderer.render(this.scene, this.camera);
            }

            handleInput(delta) {
                // Movement direction
                const direction = new THREE.Vector3();

                // Get current sprint state
                const isSprinting = this.keys['ShiftLeft'] || this.keys['ShiftRight'];
                const currentSpeed = isSprinting ? this.moveSpeed * 3.4 : this.moveSpeed;  // Reduced from 4 to 3.4 (15% slower sprint)

                // Combine keyboard WASD and gamepad left stick for movement
                if (this.keys['KeyW'] || this.gamepadState.leftStickY < -this.gamepadState.deadzone) 
                    direction.z -= 1;
                if (this.keys['KeyS'] || this.gamepadState.leftStickY > this.gamepadState.deadzone) 
                    direction.z += 1;
                if (this.keys['KeyA'] || this.gamepadState.leftStickX < -this.gamepadState.deadzone) 
                    direction.x -= 1;
                if (this.keys['KeyD'] || this.gamepadState.leftStickX > this.gamepadState.deadzone) 
                    direction.x += 1;

                // Normalize direction vector to prevent faster diagonal movement
                if (direction.length() > 0) {
                direction.normalize();
                
                    // Apply camera rotation to movement direction
                    const rotatedDirection = direction.clone();
                    rotatedDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.euler.y);
                    
                    // Set horizontal velocity based on movement direction and speed
                    this.velocity.x = rotatedDirection.x * currentSpeed;
                    this.velocity.z = rotatedDirection.z * currentSpeed;
                } else {
                    // Apply friction when not moving
                    this.velocity.x *= 0.8;
                    this.velocity.z *= 0.8;
                }

                // Apply gravity when not grounded
                if (!this.isGrounded) {
                    this.velocity.y += this.gravity * delta;
                    // Terminal velocity (like Minecraft)
                    this.velocity.y = Math.max(this.velocity.y, -19.62);
                } else {
                    // Reset vertical velocity when grounded
                    this.velocity.y = Math.max(0, this.velocity.y);
                }

                // Handle jumping
                const now = performance.now();
                if (this.keys['Space'] || this.keys['GamepadJump']) {
                    if (this.limitedJumpMode) {
                        // Limited jump mode - only check remaining jumps, no cooldown
                        if (this.remainingJumps > 0) {
                            this.velocity.y = this.jumpSpeed;
                            this.remainingJumps--;
                            console.log(`Jumps remaining: ${this.remainingJumps}`);
                        }
                    } else {
                        // Original unlimited jump mode - keeps cooldown
                        if (now - this.lastJumpTime > this.jumpCooldown) {
                            this.velocity.y = this.jumpSpeed;
                            this.lastJumpTime = now;
                        }
                    }
                }

                // Store previous position for collision reversion
                const prevPosition = this.camera.position.clone();

                // Apply movement with collision checks
                // Try X movement
                this.camera.position.x += this.velocity.x * delta;
                if (this.checkCollisions().canMove === false) {
                    this.camera.position.x = prevPosition.x;
                    this.velocity.x = 0;
                }

                // Try Z movement
                this.camera.position.z += this.velocity.z * delta;
                if (this.checkCollisions().canMove === false) {
                    this.camera.position.z = prevPosition.z;
                    this.velocity.z = 0;
                }

                // Try Y movement
                this.camera.position.y += this.velocity.y * delta;
                const collisionY = this.checkCollisions();
                if (!collisionY.canMove) {
                    this.camera.position.y = prevPosition.y;
                    this.velocity.y = 0;
                }

                // Update position display
                document.getElementById('position').textContent = 
                    `${this.camera.position.x.toFixed(1)}, ${this.camera.position.y.toFixed(1)}, ${this.camera.position.z.toFixed(1)}`;
            }
            
            checkCollisions() {
                const result = {
                    canMove: true,
                    isGrounded: false,
                    blockedDirections: {
                        forward: false,
                        backward: false,
                        left: false,
                        right: false,
                        up: false,
                        down: false
                    }
                };

                // Create player collision box with some padding
                const playerBox = new THREE.Box3();
                const playerPos = this.camera.position.clone();
                playerPos.y -= this.playerHeight;
                
                const padding = 0.1; // Add small padding for smoother collision
                playerBox.min.set(
                    playerPos.x - this.playerWidth/2 - padding,
                    playerPos.y - padding,
                    playerPos.z - this.playerWidth/2 - padding
                );
                
                playerBox.max.set(
                    playerPos.x + this.playerWidth/2 + padding,
                    playerPos.y + this.playerHeight + padding,
                    playerPos.z + this.playerWidth/2 + padding
                );

                // Ground check box (slightly below player)
                const groundBox = playerBox.clone();
                groundBox.min.y -= 0.1;
                groundBox.max.y = playerBox.min.y;

                // Get nearby chunks
                const chunkX = Math.floor(this.camera.position.x / CONFIG.CHUNK.SIZE);
                const chunkZ = Math.floor(this.camera.position.z / CONFIG.CHUNK.SIZE);
                
                // Check surrounding chunks
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        const chunk = this.world.getChunk(chunkX + dx, chunkZ + dz);
                        if (!chunk) continue;

                        // Get blocks in chunk that might collide
                        const blocks = chunk.getBlocksInRegion(
                            new THREE.Vector3(playerBox.min.x - 1, playerBox.min.y - 1, playerBox.min.z - 1),
                            new THREE.Vector3(playerBox.max.x + 1, playerBox.max.y + 1, playerBox.max.z + 1)
                        );

                        // Check collision with each block
                        for (const blockBox of blocks) {
                            // Ground check first
                            if (groundBox.intersectsBox(blockBox)) {
                                result.isGrounded = true;
                                this.isGrounded = true; // Update game's grounded state
                                if (this.limitedJumpMode) {
                                    this.remainingJumps = 5; // Reset jumps when actually touching ground
                                }
                            }

                            // Main collision check
                            if (playerBox.intersectsBox(blockBox)) {
                                result.canMove = false;
                                break;
                            }
                        }
                    }
                }

                // If not grounded after all checks, update game state
                if (!result.isGrounded) {
                    this.isGrounded = false;
                }

                return result;
            }

            // Find the height of terrain at a given x,z position
            findTerrainHeightAt(x, z) {
                // Cast a ray downward from high above the terrain
                const rayStart = new THREE.Vector3(x, 200, z);
                const raycaster = new THREE.Raycaster(rayStart, new THREE.Vector3(0, -1, 0));
                
                // Use the world's collidable meshes for consistency with collision detection
                const collidableMeshes = this.world.collidableMeshes;
                
                if (collidableMeshes.length === 0) {
                    // Fallback to all chunk meshes if the collidableMeshes array is empty
                    const allChunkMeshes = [];
                    this.world.chunks.forEach(chunk => {
                        if (chunk.mesh) {
                            allChunkMeshes.push(chunk.mesh);
                        }
                    });
                    
                    if (allChunkMeshes.length === 0) {
                        return null;
                    }
                    
                    const fallbackIntersects = raycaster.intersectObjects(allChunkMeshes);
                    if (fallbackIntersects.length > 0) {
                        console.log(`Found terrain height: ${fallbackIntersects[0].point.y} (fallback method)`);
                        return fallbackIntersects[0].point.y;
                    }
                    
                    return null;
                }
                
                const intersects = raycaster.intersectObjects(collidableMeshes);
                if (intersects.length > 0) {
                    console.log(`Found terrain height: ${intersects[0].point.y}`);
                    return intersects[0].point.y;
                }
                
                return null;
            }

            updateRockets(delta) {
                if (!this.rockets) return; // Safety check
                
                for (let i = this.rockets.length - 1; i >= 0; i--) {
                    const rocket = this.rockets[i];
                    if (!rocket || !rocket.position) {
                        this.rockets.splice(i, 1);
                        continue;
                    }
                    
                    // Apply gravity
                    rocket.velocity.y -= 9.8 * delta;
                    
                    // Update position
                    const movement = rocket.velocity.clone().multiplyScalar(delta);
                    rocket.position.add(movement);
                    
                    // Check for collisions with chunks
                    const chunkX = Math.floor(rocket.position.x / CONFIG.CHUNK.SIZE);
                    const chunkZ = Math.floor(rocket.position.z / CONFIG.CHUNK.SIZE);
                    
                    let hasCollided = false;
                    
                    // Check surrounding chunks
                    for (let dx = -1; dx <= 1 && !hasCollided; dx++) {
                        for (let dz = -1; dz <= 1 && !hasCollided; dz++) {
                            const chunk = this.world.getChunk(chunkX + dx, chunkZ + dz);
                            if (!chunk) continue;
                            
                            // Get blocks in vicinity of rocket
                            const radius = 0.5;
                            const blocks = chunk.getBlocksInRegion(
                                new THREE.Vector3(
                                    rocket.position.x - radius,
                                    rocket.position.y - radius,
                                    rocket.position.z - radius
                                ),
                                new THREE.Vector3(
                                    rocket.position.x + radius,
                                    rocket.position.y + radius,
                                    rocket.position.z + radius
                                )
                            );
                            
                            if ((blocks.length > 0 && !rocket.isConstructionRocket && !rocket.isLargeConstructionRocket && !rocket.isMassiveConstructionRocket && !rocket.isSuperMassiveConstructionRocket && !rocket.isUltraMassiveConstructionRocket && !rocket.isUltimateMassiveConstructionRocket && !rocket.isHouseRocket && !rocket.isOfficeRocket) || 
                                ((rocket.isConstructionRocket || rocket.isLargeConstructionRocket || rocket.isMassiveConstructionRocket || rocket.isSuperMassiveConstructionRocket || rocket.isUltraMassiveConstructionRocket || rocket.isUltimateMassiveConstructionRocket || rocket.isHouseRocket || rocket.isOfficeRocket) && (rocket.position.y <= 0 || blocks.length > 0))) {
                                hasCollided = true;
                                
                                if (rocket.isHouseRocket) {
                                    // Create house structure
                                    const centerX = Math.floor(rocket.position.x);
                                    const centerY = Math.floor(rocket.position.y);
                                    const centerZ = Math.floor(rocket.position.z);
                                    
                                    // Build foundation (10x10)
                                    for (let x = -5; x <= 5; x++) {
                                        for (let z = -5; z <= 5; z++) {
                                            this.world.setBlock(new THREE.Vector3(centerX + x, centerY, centerZ + z), CONFIG.BLOCKS.TYPES.STONE);
                                        }
                                    }
                                    
                                    // Build walls (8x8x4)
                                    for (let y = 1; y <= 4; y++) {
                                        for (let x = -4; x <= 4; x++) {
                                            for (let z = -4; z <= 4; z++) {
                                                // Skip interior
                                                if (x > -4 && x < 4 && z > -4 && z < 4 && y < 4) continue;
                                                // Create door
                                                if (x === 0 && z === -4 && (y === 1 || y === 2)) continue;
                                                // Create windows
                                                if (y === 2 && ((x === -2 && z === -4) || (x === 2 && z === -4) || 
                                                              (x === -2 && z === 4) || (x === 2 && z === 4) ||
                                                              (x === -4 && z === -2) || (x === -4 && z === 2) ||
                                                              (x === 4 && z === -2) || (x === 4 && z === 2))) continue;
                                                
                                                this.world.setBlock(new THREE.Vector3(centerX + x, centerY + y, centerZ + z), CONFIG.BLOCKS.TYPES.STONE);
                                            }
                                        }
                                    }
                                    
                                    // Build roof (peaked)
                                    for (let y = 5; y <= 7; y++) {
                                        for (let x = -5; x <= 5; x++) {
                                            for (let z = -5; z <= 5; z++) {
                                                // Create peaked roof effect
                                                const roofHeight = Math.abs(x) + Math.abs(z);
                                                if (roofHeight <= (8 - y)) {
                                                    this.world.setBlock(new THREE.Vector3(centerX + x, centerY + y, centerZ + z), CONFIG.BLOCKS.TYPES.STONE);
                                                }
                                            }
                                        }
                                    }
                                    
                                    // Update affected chunks
                                    const updateRadius = 1;
                                    for (let ux = -updateRadius; ux <= updateRadius; ux++) {
                                        for (let uz = -updateRadius; uz <= updateRadius; uz++) {
                                            const chunk = this.world.getChunk(chunkX + ux, chunkZ + uz);
                                            if (chunk) chunk.isDirty = true;
                                        }
                                    }
                                } else if (rocket.isOfficeRocket) {
                                    // Create office building structure
                                    const centerX = Math.floor(rocket.position.x);
                                    const centerY = Math.floor(rocket.position.y);
                                    const centerZ = Math.floor(rocket.position.z);
                                    
                                    // Build foundation (16x16)
                                    for (let x = -8; x <= 8; x++) {
                                        for (let z = -8; z <= 8; z++) {
                                            this.world.setBlock(new THREE.Vector3(centerX + x, centerY, centerZ + z), CONFIG.BLOCKS.TYPES.STONE);
                                        }
                                    }
                                    
                                    // Build 10 floors
                                    for (let floor = 0; floor < 10; floor++) {
                                        const floorY = centerY + (floor * 4) + 1; // Each floor is 4 blocks high
                                        
                                        // Build floor slab
                                        for (let x = -7; x <= 7; x++) {
                                            for (let z = -7; z <= 7; z++) {
                                                this.world.setBlock(new THREE.Vector3(centerX + x, floorY - 1, centerZ + z), CONFIG.BLOCKS.TYPES.STONE);
                                            }
                                        }
                                        
                                        // Build walls with windows
                                        for (let y = 0; y < 4; y++) {
                                            for (let x = -7; x <= 7; x++) {
                                                for (let z = -7; z <= 7; z++) {
                                                    // Skip interior
                                                    if (x > -7 && x < 7 && z > -7 && z < 7) continue;
                                                    
                                                    // Create windows
                                                    if (y === 1 || y === 2) {
                                                        // Window pattern
                                                        if ((x % 2 === 0 && (z === -7 || z === 7)) || 
                                                            (z % 2 === 0 && (x === -7 || x === 7))) {
                                                            continue; // Skip block to create window
                                                        }
                                                    }
                                                    
                                                    // Create entrance on ground floor
                                                    if (floor === 0 && (y === 1 || y === 2) && x === 0 && z === -7) {
                                                        continue;
                                                    }
                                                    
                                                    this.world.setBlock(
                                                        new THREE.Vector3(centerX + x, floorY + y, centerZ + z),
                                                        CONFIG.BLOCKS.TYPES.STONE
                                                    );
                                                }
                                            }
                                        }
                                    }
                                    
                                    // Build roof
                                    const roofY = centerY + 41; // Top of 10th floor
                                    for (let x = -8; x <= 8; x++) {
                                        for (let z = -8; z <= 8; z++) {
                                            this.world.setBlock(new THREE.Vector3(centerX + x, roofY, centerZ + z), CONFIG.BLOCKS.TYPES.STONE);
                                        }
                                    }
                                    
                                    // Update affected chunks
                                    const updateRadius = 2;
                                    for (let ux = -updateRadius; ux <= updateRadius; ux++) {
                                        for (let uz = -updateRadius; uz <= updateRadius; uz++) {
                                            const chunk = this.world.getChunk(chunkX + ux, chunkZ + uz);
                                            if (chunk) chunk.isDirty = true;
                                        }
                                    }
                                } else {
                                    // Handle other rocket types as before
                                    let effectRadius = 3; // Default rocket radius
                                    if (rocket.isNuke) effectRadius = 15;
                                    if (rocket.isMegaNuke) effectRadius = 30;
                                    if (rocket.isTotalNuke) effectRadius = 25;
                                    if (rocket.isMassiveNuke) effectRadius = 50;
                                    if (rocket.isConstructionRocket) effectRadius = 5;
                                    if (rocket.isLargeConstructionRocket) effectRadius = 10;
                                    if (rocket.isMassiveConstructionRocket) effectRadius = 20;
                                    if (rocket.isSuperMassiveConstructionRocket) effectRadius = 40;
                                    if (rocket.isUltraMassiveConstructionRocket) effectRadius = 80;
                                    if (rocket.isUltimateMassiveConstructionRocket) effectRadius = 160;
                                    
                                    // Process blocks within radius
                                    for (let x = Math.floor(rocket.position.x - effectRadius); x <= Math.ceil(rocket.position.x + effectRadius); x++) {
                                        for (let y = Math.floor(rocket.position.y - effectRadius); y <= Math.ceil(rocket.position.y + effectRadius); y++) {
                                            for (let z = Math.floor(rocket.position.z - effectRadius); z <= Math.ceil(rocket.position.z + effectRadius); z++) {
                                                const distance = new THREE.Vector3(x + 0.5, y + 0.5, z + 0.5).distanceTo(rocket.position);
                                                if (distance <= effectRadius) {
                                                    if (rocket.isConstructionRocket) {
                                                        // For regular construction rocket, create blocks with natural pattern
                                                        if ((distance / effectRadius) <= Math.random()) {
                                                            // Get the currently selected block type from the UI
                                                            const blockType = document.getElementById('blockType').value.toUpperCase();
                                                            this.world.setBlock(new THREE.Vector3(x, y, z), CONFIG.BLOCKS.TYPES[blockType]);
                                                        }
                                                    } else if (rocket.isLargeConstructionRocket || rocket.isMassiveConstructionRocket || rocket.isSuperMassiveConstructionRocket || rocket.isUltraMassiveConstructionRocket || rocket.isUltimateMassiveConstructionRocket) {
                                                        // For large/massive/super massive/ultra massive/ultimate massive construction rockets, create ALL blocks within radius
                                                        const blockType = document.getElementById('blockType').value.toUpperCase();
                                                        this.world.setBlock(new THREE.Vector3(x, y, z), CONFIG.BLOCKS.TYPES[blockType]);
                                                    } else {
                                                        // For destruction rockets, handle as before
                                                        if (rocket.isTotalNuke || rocket.isMassiveNuke || !rocket.isNuke && !rocket.isMegaNuke || (distance / effectRadius) <= Math.random()) {
                                                            this.world.setBlock(new THREE.Vector3(x, y, z), null);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    
                                    // Update affected chunks
                                    const updateRadius = Math.ceil(effectRadius / CONFIG.CHUNK.SIZE);
                                    for (let ux = -updateRadius; ux <= updateRadius; ux++) {
                                        for (let uz = -updateRadius; uz <= updateRadius; uz++) {
                                            const chunk = this.world.getChunk(chunkX + ux, chunkZ + uz);
                                            if (chunk) chunk.isDirty = true;
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Remove rocket if it has collided or exceeded lifetime
                        if (hasCollided || performance.now() - rocket.creationTime > 10000) {
                            this.scene.remove(rocket);
                            this.rockets.splice(i, 1);
                        }
                    }
                }
            }

            launchRocket() {
                // Create rocket geometry
                const rocketGeometry = new THREE.CylinderGeometry(0.1, 0.2, 0.5, 8);
                const rocketMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    metalness: 0.7,
                    roughness: 0.3
                });
                const rocket = new THREE.Mesh(rocketGeometry, rocketMaterial);
                
                // Position rocket at camera
                rocket.position.copy(this.camera.position);
                
                // Get direction from camera
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                // Set rocket velocity
                rocket.velocity = direction.multiplyScalar(50); // Speed of 50 units per second
                rocket.velocity.y += 2; // Add slight upward arc
                
                // Add to scene and rockets array
                this.scene.add(rocket);
                rocket.creationTime = performance.now();
                rocket.isNuke = false; // Flag to identify as regular rocket
                this.rockets.push(rocket);
            }

            launchNuke() {
                // Create nuke geometry (larger than regular rocket)
                const nukeGeometry = new THREE.CylinderGeometry(0.3, 0.5, 1.2, 8);
                const nukeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00ff00,
                    emissive: 0x00ff00,
                    emissiveIntensity: 0.5,
                    metalness: 0.7,
                    roughness: 0.3
                });
                const nuke = new THREE.Mesh(nukeGeometry, nukeMaterial);
                
                // Position nuke at camera
                nuke.position.copy(this.camera.position);
                
                // Get direction from camera
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                // Set nuke velocity (slower than rocket for dramatic effect)
                nuke.velocity = direction.multiplyScalar(30);
                nuke.velocity.y += 5; // Higher arc for dramatic effect
                
                // Add to scene and rockets array
                this.scene.add(nuke);
                nuke.creationTime = performance.now();
                nuke.isNuke = true; // Flag to identify as nuke in update loop
                this.rockets.push(nuke);
            }

            launchMegaNuke() {
                // Create mega nuke geometry (even larger than regular nuke)
                const nukeGeometry = new THREE.CylinderGeometry(0.5, 0.8, 2, 8);
                const nukeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.8,
                    metalness: 0.7,
                    roughness: 0.3
                });
                const nuke = new THREE.Mesh(nukeGeometry, nukeMaterial);
                
                // Position nuke at camera
                nuke.position.copy(this.camera.position);
                
                // Get direction from camera
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                // Set nuke velocity (even slower for more dramatic effect)
                nuke.velocity = direction.multiplyScalar(20);
                nuke.velocity.y += 8; // Even higher arc for dramatic effect
                
                // Add to scene and rockets array
                this.scene.add(nuke);
                nuke.creationTime = performance.now();
                nuke.isMegaNuke = true; // Special flag for mega nuke
                this.rockets.push(nuke);
            }

            launchTotalNuke() {
                // Create total destruction nuke geometry (distinctive appearance)
                const nukeGeometry = new THREE.CylinderGeometry(0.6, 1.0, 2.5, 12);
                const nukeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff00ff,  // Bright purple
                    emissive: 0xff00ff,
                    emissiveIntensity: 1.0,  // Maximum glow
                    metalness: 0.8,
                    roughness: 0.2
                });
                const nuke = new THREE.Mesh(nukeGeometry, nukeMaterial);
                
                // Position nuke at camera
                nuke.position.copy(this.camera.position);
                
                // Get direction from camera
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                // Set nuke velocity (dramatic slow movement)
                nuke.velocity = direction.multiplyScalar(25);  // Increased from 15 to 25 for more distance
                nuke.velocity.y += 6; // Adjusted from 10 to 6 for better arc
                
                // Add to scene and rockets array
                this.scene.add(nuke);
                nuke.creationTime = performance.now();
                nuke.isTotalNuke = true; // Special flag for total destruction nuke
                this.rockets.push(nuke);
            }

            launchMassiveNuke() {
                // Create massive nuke geometry (largest of all)
                const nukeGeometry = new THREE.CylinderGeometry(0.8, 1.2, 3.0, 16);
                const nukeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,  // Bright red
                    emissive: 0xff0000,
                    emissiveIntensity: 1.0,  // Maximum glow
                    metalness: 1.0,
                    roughness: 0.0,  // Perfect shine
                    transparent: true,
                    opacity: 0.8     // Slight transparency for effect
                });
                const nuke = new THREE.Mesh(nukeGeometry, nukeMaterial);
                
                // Position nuke at camera
                nuke.position.copy(this.camera.position);
                
                // Get direction from camera
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                // Set nuke velocity (slowest of all for maximum tension)
                nuke.velocity = direction.multiplyScalar(10);  // Slowest speed
                nuke.velocity.y += 12; // Highest arc for maximum dramatic effect
                
                // Add to scene and rockets array
                this.scene.add(nuke);
                nuke.creationTime = performance.now();
                nuke.isMassiveNuke = true; // Special flag for massive nuke
                this.rockets.push(nuke);
            }

            launchConstructionRocket() {
                // Create construction rocket geometry (blue/white theme)
                const rocketGeometry = new THREE.CylinderGeometry(0.2, 0.3, 0.8, 8);
                const rocketMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00ffff,  // Cyan color
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.5,
                    metalness: 0.7,
                    roughness: 0.3
                });
                const rocket = new THREE.Mesh(rocketGeometry, rocketMaterial);
                
                // Position rocket at camera
                rocket.position.copy(this.camera.position);
                
                // Get direction from camera
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                // Set rocket velocity
                rocket.velocity = direction.multiplyScalar(40); // Faster than destruction rockets
                rocket.velocity.y += 1; // Slight upward arc
                
                // Add to scene and rockets array
                this.scene.add(rocket);
                rocket.creationTime = performance.now();
                rocket.isConstructionRocket = true; // Special flag for construction rocket
                this.rockets.push(rocket);
            }

            launchLargeConstructionRocket() {
                // Create large construction rocket geometry (gold/white theme)
                const rocketGeometry = new THREE.CylinderGeometry(0.3, 0.4, 1.2, 12);
                const rocketMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffd700,  // Gold color
                    emissive: 0xffd700,
                    emissiveIntensity: 0.7,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const rocket = new THREE.Mesh(rocketGeometry, rocketMaterial);
                
                // Position rocket at camera
                rocket.position.copy(this.camera.position);
                
                // Get direction from camera
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                // Set rocket velocity
                rocket.velocity = direction.multiplyScalar(35); // Slightly slower than regular construction rocket
                rocket.velocity.y += 2; // Slightly higher arc
                
                // Add to scene and rockets array
                this.scene.add(rocket);
                rocket.creationTime = performance.now();
                rocket.isLargeConstructionRocket = true; // Special flag for large construction rocket
                this.rockets.push(rocket);
            }

            launchMassiveConstructionRocket() {
                // Create massive construction rocket geometry (platinum/diamond theme)
                const rocketGeometry = new THREE.CylinderGeometry(0.4, 0.6, 1.6, 16);
                const rocketMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xE5E4E2,  // Platinum color
                    emissive: 0xE5E4E2,
                    emissiveIntensity: 1.0,
                    metalness: 1.0,
                    roughness: 0.1
                });
                const rocket = new THREE.Mesh(rocketGeometry, rocketMaterial);
                
                // Position rocket at camera
                rocket.position.copy(this.camera.position);
                
                // Get direction from camera
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                // Set rocket velocity
                rocket.velocity = direction.multiplyScalar(30); // Even slower for more dramatic effect
                rocket.velocity.y += 3; // Higher arc for better visibility
                
                // Add to scene and rockets array
                this.scene.add(rocket);
                rocket.creationTime = performance.now();
                rocket.isMassiveConstructionRocket = true; // Special flag for massive construction rocket
                this.rockets.push(rocket);
            }

            launchSuperMassiveConstructionRocket() {
                // Create super massive construction rocket geometry (diamond/crystal theme)
                const rocketGeometry = new THREE.CylinderGeometry(0.6, 0.8, 2.0, 24);
                const rocketMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xB9F2FF,  // Diamond blue color
                    emissive: 0xB9F2FF,
                    emissiveIntensity: 1.0,
                    metalness: 1.0,
                    roughness: 0.0,  // Perfect shine
                    transparent: true,
                    opacity: 0.9     // Slight transparency for crystal effect
                });
                const rocket = new THREE.Mesh(rocketGeometry, rocketMaterial);
                
                // Position rocket at camera
                rocket.position.copy(this.camera.position);
                
                // Get direction from camera
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                // Set rocket velocity (very slow for maximum dramatic effect)
                rocket.velocity = direction.multiplyScalar(25);  // Slowest speed yet
                rocket.velocity.y += 4; // Highest arc for maximum visibility
                
                // Add to scene and rockets array
                this.scene.add(rocket);
                rocket.creationTime = performance.now();
                rocket.isSuperMassiveConstructionRocket = true; // Special flag for super massive construction rocket
                this.rockets.push(rocket);
            }

            launchUltraMassiveConstructionRocket() {
                // Create ultra massive construction rocket geometry (rainbow crystal theme)
                const rocketGeometry = new THREE.CylinderGeometry(0.8, 1.0, 2.5, 32);
                const rocketMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,  // White base for the rainbow effect
                    emissive: 0xffffff,
                    emissiveIntensity: 1.0,
                    metalness: 1.0,
                    roughness: 0.0,  // Perfect mirror finish
                    transparent: true,
                    opacity: 0.7     // More transparent for ethereal effect
                });
                const rocket = new THREE.Mesh(rocketGeometry, rocketMaterial);
                
                // Position rocket at camera
                rocket.position.copy(this.camera.position);
                
                // Get direction from camera
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                // Set rocket velocity (extremely slow for ultimate dramatic effect)
                rocket.velocity = direction.multiplyScalar(20);  // Slowest speed of all
                rocket.velocity.y += 5; // Highest arc yet
                
                // Add to scene and rockets array
                this.scene.add(rocket);
                rocket.creationTime = performance.now();
                rocket.isUltraMassiveConstructionRocket = true; // Special flag for ultra massive construction rocket
                this.rockets.push(rocket);
            }

            launchUltimateMassiveConstructionRocket() {
                // Create ultimate massive construction rocket geometry (prismatic crystal theme)
                const rocketGeometry = new THREE.CylinderGeometry(1.0, 1.2, 3.0, 48);
                const rocketMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,  // Pure white base
                    emissive: 0xffffff,
                    emissiveIntensity: 1.0,
                    metalness: 1.0,
                    roughness: 0.0,  // Perfect mirror finish
                    transparent: true,
                    opacity: 0.5     // More transparent for ultimate ethereal effect
                });
                const rocket = new THREE.Mesh(rocketGeometry, rocketMaterial);
                
                // Position rocket at camera
                rocket.position.copy(this.camera.position);
                
                // Get direction from camera
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                // Set rocket velocity (most dramatic movement yet)
                rocket.velocity = direction.multiplyScalar(15);  // Slowest speed for maximum anticipation
                rocket.velocity.y += 6; // Highest arc for ultimate dramatic effect
                
                // Add to scene and rockets array
                this.scene.add(rocket);
                rocket.creationTime = performance.now();
                rocket.isUltimateMassiveConstructionRocket = true; // Special flag for ultimate massive construction rocket
                this.rockets.push(rocket);
            }

            launchHouseConstructionRocket() {
                // Create house construction rocket geometry
                const rocketGeometry = new THREE.CylinderGeometry(0.3, 0.4, 1.0, 8);
                const rocketMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513,  // Brown color for house theme
                    emissive: 0x8B4513,
                    emissiveIntensity: 0.5,
                    metalness: 0.7,
                    roughness: 0.3
                });
                const rocket = new THREE.Mesh(rocketGeometry, rocketMaterial);
                
                // Position rocket at camera
                rocket.position.copy(this.camera.position);
                
                // Get direction from camera
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                // Set rocket velocity
                rocket.velocity = direction.multiplyScalar(30);
                rocket.velocity.y += 2; // Slight upward arc
                
                // Add to scene and rockets array
                this.scene.add(rocket);
                rocket.creationTime = performance.now();
                rocket.isHouseRocket = true; // Special flag for house construction
                this.rockets.push(rocket);
            }

            launchOfficeConstructionRocket() {
                // Create office building construction rocket geometry
                const rocketGeometry = new THREE.CylinderGeometry(0.4, 0.5, 1.2, 12);
                const rocketMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x4682B4,  // Steel blue color for modern look
                    emissive: 0x4682B4,
                    emissiveIntensity: 0.6,
                    metalness: 0.9,
                    roughness: 0.2
                });
                const rocket = new THREE.Mesh(rocketGeometry, rocketMaterial);
                
                // Position rocket at camera
                rocket.position.copy(this.camera.position);
                
                // Get direction from camera
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                // Set rocket velocity
                rocket.velocity = direction.multiplyScalar(30);
                rocket.velocity.y += 2;
                
                // Add to scene and rockets array
                this.scene.add(rocket);
                rocket.creationTime = performance.now();
                rocket.isOfficeRocket = true;
                this.rockets.push(rocket);
            }

            // Modify setBlock to broadcast changes
            setBlock(position, type) {
                this.world.setBlock(position, type);
                
                if (this.networkManager && this.networkManager.isConnected) {
                    this.networkManager.send({
                        type: NetworkMessageType.BLOCK_UPDATE,
                        data: {
                            position: position.toArray(),
                            blockType: type
                        }
                    });
                }
            }

            setupMultiplayerUI() {
                const connectBtn = document.getElementById('connect-btn');
                const serverUrl = document.getElementById('server-url');
                const playerCount = document.getElementById('player-count');
                const multiplayerUI = document.getElementById('multiplayer-ui');
                const playerList = document.querySelector('.player-list');

                connectBtn.addEventListener('click', () => {
                    if (this.networkManager.isConnected) {
                        // Disconnect
                        this.networkManager.ws.close();
                        connectBtn.textContent = 'Connect';
                        connectBtn.classList.remove('disconnecting');
                        multiplayerUI.classList.remove('connected');
                        multiplayerUI.classList.add('disconnected');
                        playerList.classList.remove('visible');
                    } else {
                        // Connect
                        this.networkManager.connect(serverUrl.value);
                        connectBtn.textContent = 'Disconnect';
                        connectBtn.classList.add('disconnecting');
                        multiplayerUI.classList.add('connected');
                        multiplayerUI.classList.remove('disconnected');
                        playerList.classList.add('visible');
                    }
                });

                // Update player count
                setInterval(() => {
                    if (this.networkManager.isConnected) {
                        const count = this.networkManager.players.size + 1; // +1 for local player
                        playerCount.textContent = `Players: ${count}`;
                        
                        // Update player list
                        const playerListContent = document.getElementById('player-list-content');
                        playerListContent.innerHTML = '';
                        
                        // Add local player
                        const localPlayer = document.createElement('div');
                        localPlayer.className = 'player-list-item';
                        localPlayer.textContent = `You (${this.networkManager.playerId})`;
                        playerListContent.appendChild(localPlayer);
                        
                        // Add other players
                        this.networkManager.players.forEach((player, id) => {
                            const playerElement = document.createElement('div');
                            playerElement.className = 'player-list-item';
                            playerElement.textContent = `Player ${id}`;
                            playerListContent.appendChild(playerElement);
                        });
                    }
                }, 1000);
            }

            createTree(pos, size) {
                const height = size === 'large' ? 12 : 6;
                const trunkHeight = Math.floor(height * 0.6);
                const leafRadius = Math.floor(height * 0.4);

                // Create trunk
                for (let y = 0; y < trunkHeight; y++) {
                    this.setBlock(pos.x, pos.y + y, pos.z, 'oak_log');
                }

                // Create leaves in a natural pattern
                for (let x = -leafRadius; x <= leafRadius; x++) {
                    for (let y = 0; y < leafRadius * 2; y++) {
                        for (let z = -leafRadius; z <= leafRadius; z++) {
                            const distance = Math.sqrt(x*x + z*z);
                            if (distance <= leafRadius * (1 - y/(leafRadius * 2.5))) {
                                this.setBlock(
                                    pos.x + x,
                                    pos.y + trunkHeight + y,
                                    pos.z + z,
                                    'leaves'
                                );
                            }
                        }
                    }
                }
            }

            createRoad(pos, direction) {
                const length = 20;
                const width = 3;
                
                const startX = pos.x - (direction === 'EW' ? length/2 : width/2);
                const startZ = pos.z - (direction === 'NS' ? length/2 : width/2);
                
                // Create road surface
                for (let x = 0; x < (direction === 'EW' ? length : width); x++) {
                    for (let z = 0; z < (direction === 'NS' ? length : width); z++) {
                        this.setBlock(startX + x, pos.y - 1, startZ + z, 'stone');
                        // Add fences on the sides
                        if (direction === 'NS' && (z === 0 || z === length-1)) {
                            this.setBlock(startX + x, pos.y, startZ + z, 'fence');
                        } else if (direction === 'EW' && (x === 0 || x === length-1)) {
                            this.setBlock(startX + x, pos.y, startZ + z, 'fence');
                        }
                    }
                }
            }

            createGarden(pos) {
                const size = 10;
                // Create garden border
                for (let x = -size; x <= size; x++) {
                    for (let z = -size; z <= size; z++) {
                        if (Math.abs(x) === size || Math.abs(z) === size) {
                            this.setBlock(pos.x + x, pos.y - 1, pos.z + z, 'stone');
                            this.setBlock(pos.x + x, pos.y, pos.z + z, 'fence');
                        } else {
                            this.setBlock(pos.x + x, pos.y - 1, pos.z + z, 'dirt');
                            // Add random flowers and grass
                            if (Math.random() < 0.3) {
                                this.setBlock(pos.x + x, pos.y, pos.z + z, Math.random() < 0.5 ? 'flower' : 'tall_grass');
                            }
                        }
                    }
                }
            }

            createIslandscape(pos) {
                const size = 30;
                const waterLevel = pos.y - 5;
                
                for (let x = -size; x <= size; x++) {
                    for (let z = -size; z <= size; z++) {
                        // Generate island height using noise
                        const distance = Math.sqrt(x*x + z*z) / size;
                        const height = Math.floor((1 - distance) * 8 * Math.random());
                        
                        // Create deep water
                        for (let y = waterLevel - 3; y <= waterLevel; y++) {
                            this.setBlock(pos.x + x, y, pos.z + z, 'water');
                        }
                        
                        // Create islands
                        if (height > 0) {
                            for (let y = waterLevel - 3; y <= waterLevel + height; y++) {
                                const block = y === waterLevel + height ? 'grass' : 'dirt';
                                this.setBlock(pos.x + x, y, pos.z + z, block);
                            }
                        }
                    }
                }
            }

            createPalace(pos) {
                const size = 15;
                const height = 20;
                
                // Create main structure
                for (let x = -size; x <= size; x++) {
                    for (let z = -size; z <= size; z++) {
                        for (let y = 0; y < height; y++) {
                            // Create walls
                            if (Math.abs(x) === size || Math.abs(z) === size || y === 0 || y === height-1) {
                                this.setBlock(pos.x + x, pos.y + y, pos.z + z, 'quartz');
                            }
                            // Add decorative gold trim
                            if ((y % 5 === 0) && (Math.abs(x) === size || Math.abs(z) === size)) {
                                this.setBlock(pos.x + x, pos.y + y, pos.z + z, 'gold');
                            }
                        }
                    }
                }
                
                // Add towers at corners
                const towerPositions = [
                    [size, size], [-size, size], [size, -size], [-size, -size]
                ];
                towerPositions.forEach(([x, z]) => {
                    for (let y = 0; y < height + 10; y++) {
                        for (let dx = -2; dx <= 2; dx++) {
                            for (let dz = -2; dz <= 2; dz++) {
                                if (Math.abs(dx) === 2 || Math.abs(dz) === 2) {
                                    this.setBlock(pos.x + x + dx, pos.y + y, pos.z + z + dz, 'quartz');
                                }
                            }
                        }
                    }
                });
            }

            createMaze(pos) {
                const size = 15;
                const height = 3;
                const maze = this.generateMaze(size);
                
                // Create maze walls
                for (let x = 0; x < size * 2 + 1; x++) {
                    for (let z = 0; z < size * 2 + 1; z++) {
                        if (maze[x][z] === 1) {
                            for (let y = 0; y < height; y++) {
                                this.setBlock(pos.x + x - size, pos.y + y, pos.z + z - size, 'stone');
                            }
                        }
                    }
                }
            }

            generateMaze(size) {
                const maze = Array(size * 2 + 1).fill().map(() => Array(size * 2 + 1).fill(1));
                const stack = [[1, 1]];
                maze[1][1] = 0;
                
                while (stack.length > 0) {
                    const [x, z] = stack[stack.length - 1];
                    const directions = [
                        [0, 2], [2, 0], [0, -2], [-2, 0]
                    ].sort(() => Math.random() - 0.5);
                    
                    let moved = false;
                    for (const [dx, dz] of directions) {
                        const nx = x + dx, nz = z + dz;
                        if (nx > 0 && nx < size * 2 && nz > 0 && nz < size * 2 && maze[nx][nz] === 1) {
                            maze[x + dx/2][z + dz/2] = 0;
                            maze[nx][nz] = 0;
                            stack.push([nx, nz]);
                            moved = true;
                            break;
                        }
                    }
                    if (!moved) stack.pop();
                }
                return maze;
            }

            createSpaceX(pos) {
                const rocketHeight = 30;
                const baseRadius = 2;
                
                // Create launch pad
                for (let x = -10; x <= 10; x++) {
                    for (let z = -10; z <= 10; z++) {
                        this.setBlock(pos.x + x, pos.y - 1, pos.z + z, 'metal');
                        if (Math.abs(x) === 10 || Math.abs(z) === 10) {
                            this.setBlock(pos.x + x, pos.y, pos.z + z, 'fence');
                        }
                    }
                }
                
                // Create rocket body
                for (let y = 0; y < rocketHeight; y++) {
                    const radius = y < rocketHeight - 5 ? baseRadius : 
                                 baseRadius - (y - (rocketHeight - 5)) * 0.4;
                    
                    for (let x = -Math.ceil(radius); x <= Math.ceil(radius); x++) {
                        for (let z = -Math.ceil(radius); z <= Math.ceil(radius); z++) {
                            if (x*x + z*z <= radius*radius) {
                                this.setBlock(pos.x + x, pos.y + y, pos.z + z, 'metal');
                            }
                        }
                    }
                }
                
                // Add fins
                const finPositions = [[1,0], [-1,0], [0,1], [0,-1]];
                finPositions.forEach(([x, z]) => {
                    for (let y = 0; y < 5; y++) {
                        this.setBlock(pos.x + x * (baseRadius + 1), pos.y + y, pos.z + z * (baseRadius + 1), 'metal');
                    }
                });
            }

            // Add gamepad handling
            gamepadLoop() {
                const gamepads = navigator.getGamepads();
                if (gamepads[0]) {
                    this.handleGamepad(gamepads[0]);
                }
                requestAnimationFrame(() => this.gamepadLoop());
            }

            handleGamepad(gamepad) {
                const state = this.gamepadState;

                // Handle analog sticks (with deadzone and normalization)
                const normalizeStickInput = (x, y) => {
                    const magnitude = Math.sqrt(x * x + y * y);
                    if (magnitude < state.deadzone) {
                        return [0, 0];
                    }
                    // Normalize and adjust for deadzone
                    const normalizedX = x / magnitude;
                    const normalizedY = y / magnitude;
                    // Scale the input to be smooth from deadzone to 1
                    const scale = Math.min(1, (magnitude - state.deadzone) / (1 - state.deadzone));
                    return [normalizedX * scale, normalizedY * scale];
                };

                // Normalize left stick
                [state.leftStickX, state.leftStickY] = normalizeStickInput(gamepad.axes[0], gamepad.axes[1]);
                
                // Normalize right stick and apply smoothing
                const [normalizedX, normalizedY] = normalizeStickInput(gamepad.axes[2], gamepad.axes[3]);
                
                // Camera control with right stick using quaternions
                if (normalizedX !== 0 || normalizedY !== 0) {
                    // Create rotation quaternions
                    const yawQuat = new THREE.Quaternion();
                    const pitchQuat = new THREE.Quaternion();
                    
                    // Set up rotation axes (ensure world-space up vector)
                    const yawAxis = new THREE.Vector3(0, 1, 0);
                    const rightVector = new THREE.Vector3(1, 0, 0);
                    rightVector.applyQuaternion(this.camera.quaternion);
                    rightVector.y = 0; // Force horizontal rotation axis
                    rightVector.normalize();
                    
                    // Calculate rotation amounts with smooth sensitivity
                    const yawAngle = -normalizedX * state.lookSensitivity;
                    const pitchAngle = -normalizedY * state.lookSensitivity;
                    
                    // Create the rotations
                    yawQuat.setFromAxisAngle(yawAxis, yawAngle);
                    pitchQuat.setFromAxisAngle(rightVector, pitchAngle);
                    
                    // Apply yaw rotation first
                    this.camera.quaternion.multiply(yawQuat);
                    
                    // Get current pitch and limit it
                    this.euler.setFromQuaternion(this.camera.quaternion);
                    this.euler.x = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, this.euler.x + pitchAngle));
                    this.euler.z = 0; // Force no roll/tilt
                    this.camera.quaternion.setFromEuler(this.euler);
                }

                // Button mappings (Xbox controller)
                const buttonPressed = (index) => gamepad.buttons[index].pressed;
                const buttonJustPressed = (index) => gamepad.buttons[index].pressed && !state.lastButtons[index];

                // A Button (Jump) - Store in separate controller state
                this.keys['GamepadJump'] = buttonPressed(0);
                
                // B Button (Break Block)
                if (buttonPressed(1)) {
                    this.selectedTool = 'delete';
                    this.handleBlockInteraction('delete');
                }

                // X Button (Place Block)
                if (buttonPressed(2)) {
                    this.selectedTool = 'block';
                    this.handleBlockInteraction('block');
                }

                // Y Button (Toggle Camera)
                if (buttonJustPressed(3)) {
                    this.keys['KeyF'] = true;
                    setTimeout(() => { this.keys['KeyF'] = false; }, 100);
                }

                // Y Button - Launch Massive Nuke (largest deletion radius)
                if (buttonPressed(3)) {
                    this.launchMassiveNuke();
                }

                // D-pad Up - Launch House Construction
                if (buttonPressed(12)) {
                    this.launchHouseConstructionRocket();
                }

                // D-pad Right - Launch Office Building Construction
                if (buttonPressed(15)) {
                    this.launchOfficeConstructionRocket();
                }

                // Left Stick Click (L3) - Toggle Sprint
                if (buttonJustPressed(10)) {
                    this.sprintToggled = !this.sprintToggled; // Toggle sprint state
                }
                this.keys['ShiftLeft'] = this.sprintToggled; // Apply sprint state

                // Left Bumper - Launch Massive Construction Rocket
                if (buttonPressed(4)) {
                    this.launchMassiveConstructionRocket();
                }

                // Right Bumper - Launch Total Nuke
                if (buttonPressed(5)) {
                    this.launchTotalNuke();
                }

                // Left Trigger (LT) - Launch Construction Rocket
                if (gamepad.buttons[6].value > 0.5) {
                    this.launchConstructionRocket();
                }

                // Right Trigger (RT) - Launch Regular Rocket
                if (gamepad.buttons[7].value > 0.5) {
                    this.launchRocket();
                }

                // Update last button states
                for (let i = 0; i < gamepad.buttons.length; i++) {
                    state.lastButtons[i] = gamepad.buttons[i].pressed;
                }

                // X Button (Queue functionality - Q key)
                if (buttonPressed(2)) {
                    this.keys['KeyQ'] = true;
                } else {
                    this.keys['KeyQ'] = false;
                }

                // B Button (E key functionality)
                if (buttonPressed(1)) {
                    this.keys['KeyE'] = true;
                } else {
                    this.keys['KeyE'] = false;
                }
            }
        }

        // Network message types
        const NetworkMessageType = {
            CONNECT: 'connect',
            DISCONNECT: 'disconnect',
            PLAYER_UPDATE: 'player_update',
            BLOCK_UPDATE: 'block_update',
            CHUNK_REQUEST: 'chunk_request',
            CHUNK_DATA: 'chunk_data',
            CHUNK_UPDATE: 'chunk_update',
            PLAYER_ACTION: 'player_action',
            GAME_STATE: 'game_state'
        };

        // Network message queue for handling message ordering
        class MessageQueue {
            constructor() {
                this.queue = [];
                this.sequenceNumber = 0;
            }

            enqueue(message) {
                this.queue.push({
                    ...message,
                    sequence: this.sequenceNumber++,
                    timestamp: Date.now()
                });
            }

            dequeue() {
                return this.queue.shift();
            }

            peek() {
                return this.queue[0];
            }

            isEmpty() {
                return this.queue.length === 0;
            }
        }

        // Network Constants
        const NETWORK_CONSTANTS = {
            MAX_MESSAGE_SIZE: 16384, // 16KB
            MAX_MOVEMENT_SPEED: 50,  // blocks per second
            BATCH_INTERVAL: 50,      // 20 updates per second
            RATE_LIMITS: {
                PLAYER_UPDATE: { count: 20, interval: 1000 },  // 20 updates per second
                BLOCK_UPDATE: { count: 10, interval: 1000 },   // 10 block updates per second
                CHUNK_REQUEST: { count: 5, interval: 1000 }    // 5 chunk requests per second
            }
        };

        // Rate limiter for network messages
        class RateLimiter {
            constructor() {
                this.limits = new Map();
            }

            checkLimit(type) {
                const limit = NETWORK_CONSTANTS.RATE_LIMITS[type];
                if (!limit) return true;

                const now = Date.now();
                const key = `${type}_${Math.floor(now / limit.interval)}`;
                const count = this.limits.get(key) || 0;

                if (count >= limit.count) return false;

                this.limits.set(key, count + 1);
                return true;
            }

            cleanup() {
                const now = Date.now();
                for (const [key] of this.limits) {
                    const [type, interval] = key.split('_');
                    if (parseInt(interval) < Math.floor(now / NETWORK_CONSTANTS.RATE_LIMITS[type].interval)) {
                        this.limits.delete(key);
                    }
                }
            }
        }

        // Enhanced PlayerState with validation
        class PlayerState {
            constructor(id, position, rotation) {
                this.id = id;
                this.position = position.clone();
                this.rotation = rotation.clone();
                this.lastUpdate = Date.now();
                this.sequence = 0;
                this.inventory = [];
                this.health = 100;
                this.isConnected = true;
                this.lastValidPosition = position.clone();
                this.lastMoveTime = Date.now();
                
                // Physics properties
                this.velocity = new THREE.Vector3();
                this.acceleration = new THREE.Vector3();
                this.boundingBox = new THREE.Box3();
                this.updateBoundingBox();
                
                // Combat properties
                this.lastDamageTime = 0;
                this.isInvulnerable = false;
                this.activeEffects = new Map();
                
                // Action cooldowns
                this.lastActionTime = new Map();
                for (const action of Object.values(PLAYER_INTERACTION.ACTION_TYPES)) {
                    this.lastActionTime.set(action, 0);
                }
            }

            updateBoundingBox() {
                const pad = PLAYER_INTERACTION.COLLISION_PADDING;
                this.boundingBox.setFromCenterAndSize(
                    this.position,
                    new THREE.Vector3(0.6 + pad, 1.8 + pad, 0.6 + pad)
                );
            }

            validateUpdate(data) {
                const now = Date.now();
                const timeDelta = (now - this.lastMoveTime) / 1000;
                
                if (Math.abs(data.position.y) > 1000) {
                    console.warn('Invalid position: Y out of bounds');
                    return false;
                }

                const distance = this.position.distanceTo(data.position);
                const speed = distance / timeDelta;
                if (speed > NETWORK_CONSTANTS.MAX_MOVEMENT_SPEED) {
                    console.warn('Invalid movement: Speed too high');
                    return false;
                }

                if (data.sequence <= this.sequence) {
                    console.warn('Invalid sequence number');
                    return false;
                }

                return true;
            }

            update(data) {
                if (!this.validateUpdate(data)) {
                    this.position.copy(this.lastValidPosition);
                    return false;
                }
                
                this.lastValidPosition.copy(this.position);
                this.position.copy(data.position);
                this.rotation.copy(data.rotation);
                this.lastUpdate = Date.now();
                this.lastMoveTime = Date.now();
                this.sequence = data.sequence;
                this.updateBoundingBox();
                return true;
            }

            canPerformAction(actionType) {
                const now = Date.now();
                const lastTime = this.lastActionTime.get(actionType) || 0;
                
                switch (actionType) {
                    case PLAYER_INTERACTION.ACTION_TYPES.BLOCK_BREAK:
                        return now - lastTime >= 250;
                    case PLAYER_INTERACTION.ACTION_TYPES.BLOCK_PLACE:
                        return now - lastTime >= 250;
                    case PLAYER_INTERACTION.ACTION_TYPES.ATTACK:
                        return now - lastTime >= 500;
                    case PLAYER_INTERACTION.ACTION_TYPES.INTERACT:
                        return now - lastTime >= 200;
                    default:
                        return false;
                }
            }

            performAction(actionType) {
                if (!this.canPerformAction(actionType)) return false;
                this.lastActionTime.set(actionType, Date.now());
                return true;
            }

            takeDamage(amount, source) {
                const now = Date.now();
                if (this.isInvulnerable || now - this.lastDamageTime < PLAYER_INTERACTION.DAMAGE_COOLDOWN) {
                    return false;
                }

                this.health = Math.max(0, this.health - amount);
                this.lastDamageTime = now;
                return true;
            }
        }

        // Chunk state tracking
        class ChunkState {
            constructor(chunk) {
                this.chunk = chunk;
                this.version = 0;
                this.lastUpdate = Date.now();
                this.owner = null;
                this.pendingUpdates = new Map();
                this.blockChanges = new Set();
                this.lastSyncVersion = 0;
                this.isLocked = false;
            }

            lock(playerId) {
                if (this.isLocked && this.owner !== playerId) return false;
                this.isLocked = true;
                this.owner = playerId;
                this.lastUpdate = Date.now();
                return true;
            }

            unlock() {
                this.isLocked = false;
                this.owner = null;
            }

            addChange(x, y, z, blockId) {
                this.blockChanges.add(JSON.stringify({x, y, z, blockId}));
                this.version++;
            }

            getChanges() {
                const changes = Array.from(this.blockChanges).map(change => JSON.parse(change));
                this.blockChanges.clear();
                return changes;
            }

            shouldSendFullChunk() {
                return this.blockChanges.size > CHUNK_SYNC.DIFF_THRESHOLD;
            }
        }

        // Main NetworkManager class
        class NetworkManager {
            constructor(game) {
                this.game = game;
                this.messageQueue = new MessageQueue();
                this.players = new Map();
                this.connectionAttempts = 0;
                this.maxRetries = 5;
                this.retryDelay = 1000;
                this.lastUpdateTime = 0;
                this.updateRate = NETWORK_CONSTANTS.BATCH_INTERVAL;
                this.isConnected = false;
                this.playerId = null;
                
                // Network features
                this.rateLimiter = new RateLimiter();
                this.batchedUpdates = new Map();
                this.lastBatchTime = 0;
                
                // Managers
                this.chunkStates = new Map();
                this.playerInteractionManager = new PlayerInteractionManager(this);
                
                // Bind methods
                this.onOpen = this.onOpen.bind(this);
                this.onClose = this.onClose.bind(this);
                this.onMessage = this.onMessage.bind(this);
                this.onError = this.onError.bind(this);
            }

            connect(serverUrl) {
                try {
                    this.ws = new WebSocket(serverUrl);
                    this.ws.onopen = this.onOpen;
                    this.ws.onclose = this.onClose;
                    this.ws.onmessage = this.onMessage;
                    this.ws.onerror = this.onError;
                } catch (error) {
                    console.error('Failed to connect:', error);
                    this.retryConnection();
                }
            }

            onOpen() {
                console.log('Connected to server');
                this.isConnected = true;
                this.connectionAttempts = 0;
                
                this.send({
                    type: NetworkMessageType.CONNECT,
                    data: {
                        position: this.game.camera.position.toArray(),
                        rotation: this.game.camera.rotation.toArray()
                    }
                });
            }

            onClose() {
                console.log('Disconnected from server');
                this.isConnected = false;
                this.retryConnection();
            }

            onError(error) {
                console.error('WebSocket error:', error);
                this.isConnected = false;
            }

            retryConnection() {
                if (this.connectionAttempts < this.maxRetries) {
                    this.connectionAttempts++;
                    setTimeout(() => {
                        console.log(`Retrying connection (${this.connectionAttempts}/${this.maxRetries})...`);
                        this.connect(this.serverUrl);
                    }, this.retryDelay * this.connectionAttempts);
                }
            }

            validateMessage(message) {
                if (JSON.stringify(message).length > NETWORK_CONSTANTS.MAX_MESSAGE_SIZE) {
                    console.warn('Message too large');
                    return false;
                }

                if (!this.rateLimiter.checkLimit(message.type)) {
                    console.warn('Rate limit exceeded for message type:', message.type);
                    return false;
                }

                return true;
            }

            onMessage(event) {
                try {
                    const message = JSON.parse(event.data);
                    if (!this.validateMessage(message)) return;
                    
                    this.messageQueue.enqueue(message);
                    this.processMessages();
                } catch (error) {
                    console.error('Error processing message:', error);
                }
            }

            processMessages() {
                while (!this.messageQueue.isEmpty()) {
                    const message = this.messageQueue.dequeue();
                    
                    switch (message.type) {
                        case NetworkMessageType.CONNECT:
                            this.handleConnect(message.data);
                            break;
                        case NetworkMessageType.DISCONNECT:
                            this.handleDisconnect(message.data);
                            break;
                        case NetworkMessageType.PLAYER_UPDATE:
                            this.handlePlayerUpdate(message.data);
                            break;
                        case NetworkMessageType.BLOCK_UPDATE:
                            this.handleBlockUpdate(message.data);
                            break;
                        case NetworkMessageType.CHUNK_DATA:
                            this.handleChunkData(message.data);
                            break;
                        case NetworkMessageType.CHUNK_UPDATE:
                            this.handleChunkUpdate(message.data);
                            break;
                        default:
                            console.warn('Unknown message type:', message.type);
                    }
                }
            }

            handleConnect(data) {
                if (data.playerId) {
                    this.playerId = data.playerId;
                    console.log('Received player ID:', this.playerId);
                }
                
                if (data.players) {
                    data.players.forEach(playerData => {
                        if (playerData.id !== this.playerId) {
                            this.players.set(playerData.id, new PlayerState(
                                playerData.id,
                                new THREE.Vector3().fromArray(playerData.position),
                                new THREE.Euler().fromArray(playerData.rotation)
                            ));
                        }
                    });
                }
            }

            handleDisconnect(data) {
                if (data.playerId && this.players.has(data.playerId)) {
                    this.players.delete(data.playerId);
                }
            }

            handlePlayerUpdate(data) {
                if (data.playerId === this.playerId) return;
                
                let player = this.players.get(data.playerId);
                if (!player) {
                    player = new PlayerState(
                        data.playerId,
                        new THREE.Vector3().fromArray(data.position),
                        new THREE.Euler().fromArray(data.rotation)
                    );
                    this.players.set(data.playerId, player);
                } else {
                    const newPosition = new THREE.Vector3().fromArray(data.position);
                    if (!this.playerInteractionManager.checkCollision(player, newPosition)) {
                        player.update({
                            position: newPosition,
                            rotation: new THREE.Euler().fromArray(data.rotation),
                            sequence: data.sequence
                        });
                    }
                }
            }

            handleBlockUpdate(data) {
                const position = new THREE.Vector3().fromArray(data.position);
                if (!this.playerInteractionManager.validateAction(data.playerId, PLAYER_INTERACTION.ACTION_TYPES.BLOCK_PLACE)) {
                    return;
                }
                this.game.world.setBlock(position, data.blockType, false);
            }

            handleChunkData(data) {
                const chunk = this.game.world.getChunk(data.x, data.z);
                if (chunk) {
                    chunk.deserialize(data.blocks);
                    chunk.isDirty = true;
                }
            }

            handleChunkUpdate(data) {
                const chunk = this.game.world.getChunk(data.x, data.z);
                if (!chunk) return;

                if (data.changes) {
                    data.changes.forEach(change => {
                        chunk.setBlock(change.x, change.y, change.z, change.blockId);
                    });
                }
                chunk.isDirty = true;
            }

            queueUpdate(type, data) {
                if (!this.batchedUpdates.has(type)) {
                    this.batchedUpdates.set(type, []);
                }
                this.batchedUpdates.get(type).push(data);
            }

            flushUpdates() {
                const now = Date.now();
                if (now - this.lastBatchTime < this.updateRate) return;

                this.batchedUpdates.forEach((updates, type) => {
                    if (updates.length > 0) {
                        this.send({
                            type,
                            data: updates.length === 1 ? updates[0] : updates
                        });
                        updates.length = 0;
                    }
                });

                this.lastBatchTime = now;
                this.rateLimiter.cleanup();
            }

            send(message) {
                if (!this.isConnected) return;
                
                try {
                    this.ws.send(JSON.stringify({
                        ...message,
                        timestamp: Date.now(),
                        playerId: this.playerId
                    }));
                } catch (error) {
                    console.error('Error sending message:', error);
                }
            }

            update() {
                const now = Date.now();
                if (now - this.lastUpdateTime < this.updateRate) return;
                
                if (this.isConnected) {
                    this.queueUpdate(NetworkMessageType.PLAYER_UPDATE, {
                        position: this.game.camera.position.toArray(),
                        rotation: this.game.camera.rotation.toArray(),
                        sequence: this.messageQueue.sequenceNumber
                    });
                    
                    this.flushUpdates();
                    this.playerInteractionManager.updateSpatialHash();
                    this.playerInteractionManager.updateVisibility();
                }
                
                this.lastUpdateTime = now;
            }
        }

        // Player interaction constants
        const PLAYER_INTERACTION = {
            COLLISION_PADDING: 0.3,
            INTERACTION_RANGE: 5,
            VISIBILITY_RANGE: 32,  // In blocks
            MAX_HEALTH: 100,
            DAMAGE_COOLDOWN: 500,  // ms
            ACTION_TYPES: {
                BLOCK_BREAK: 'block_break',
                BLOCK_PLACE: 'block_place',
                ATTACK: 'attack',
                INTERACT: 'interact'
            }
        };

        // Player interaction manager
        class PlayerInteractionManager {
            constructor(game) {
                this.game = game;
                this.spatialHash = new Map();
                this.cellSize = 16;  // Size of spatial hash cells
                this.visiblePlayers = new Set();
            }

            updateSpatialHash() {
                this.spatialHash.clear();
                
                // Add local player
                this.addToSpatialHash(this.game.networkManager.playerId, this.game.camera.position);
                
                // Add other players
                this.game.networkManager.players.forEach((player, id) => {
                    this.addToSpatialHash(id, player.position);
                });
            }

            addToSpatialHash(playerId, position) {
                const cellX = Math.floor(position.x / this.cellSize);
                const cellZ = Math.floor(position.z / this.cellSize);
                const key = `${cellX},${cellZ}`;
                
                if (!this.spatialHash.has(key)) {
                    this.spatialHash.set(key, new Set());
                }
                this.spatialHash.get(key).add(playerId);
            }

            getNearbyPlayers(position, range) {
                const nearby = new Set();
                const cellRange = Math.ceil(range / this.cellSize);
                const centerX = Math.floor(position.x / this.cellSize);
                const centerZ = Math.floor(position.z / this.cellSize);
                
                for (let x = -cellRange; x <= cellRange; x++) {
                    for (let z = -cellRange; z <= cellRange; z++) {
                        const key = `${centerX + x},${centerZ + z}`;
                        const cell = this.spatialHash.get(key);
                        if (cell) {
                            cell.forEach(playerId => {
                                const player = this.game.networkManager.players.get(playerId);
                                if (player && player.position.distanceTo(position) <= range) {
                                    nearby.add(playerId);
                                }
                            });
                        }
                    }
                }
                
                return nearby;
            }

            checkCollision(playerState, newPosition) {
                // Update bounding box with new position
                const tempBox = playerState.boundingBox.clone();
                const movement = newPosition.clone().sub(playerState.position);
                tempBox.translate(movement);
                
                // Check collision with blocks
                const min = tempBox.min.floor();
                const max = tempBox.max.ceil();
                
                for (let x = min.x; x <= max.x; x++) {
                    for (let y = min.y; y <= max.y; y++) {
                        for (let z = min.z; z <= max.z; z++) {
                            const block = this.game.world.getBlock(x, y, z);
                            if (block && block !== 0) {  // 0 is air
                                const blockBox = new THREE.Box3(
                                    new THREE.Vector3(x, y, z),
                                    new THREE.Vector3(x + 1, y + 1, z + 1)
                                );
                                if (tempBox.intersectsBox(blockBox)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                
                // Check collision with other players
                const nearby = this.getNearbyPlayers(newPosition, 2);
                for (const otherId of nearby) {
                    if (otherId === playerState.id) continue;
                    
                    const other = this.game.networkManager.players.get(otherId);
                    if (other && tempBox.intersectsBox(other.boundingBox)) {
                        return true;
                    }
                }
                
                return false;
            }

            validateAction(playerId, actionType, target) {
                const player = this.game.networkManager.players.get(playerId);
                if (!player) return false;

                // Check if player can perform the action
                if (!player.canPerformAction(actionType)) return false;

                // Check range
                if (target && target.distanceTo(player.position) > PLAYER_INTERACTION.INTERACTION_RANGE) {
                    return false;
                }

                return true;
            }

            updateVisibility() {
                const oldVisible = new Set(this.visiblePlayers);
                this.visiblePlayers.clear();
                
                // Get players in visibility range
                const nearby = this.getNearbyPlayers(
                    this.game.camera.position,
                    PLAYER_INTERACTION.VISIBILITY_RANGE
                );
                
                // Check line of sight for each nearby player
                nearby.forEach(playerId => {
                    const player = this.game.networkManager.players.get(playerId);
                    if (!player) return;
                    
                    // Simple line of sight check
                    const direction = player.position.clone().sub(this.game.camera.position);
                    const distance = direction.length();
                    direction.normalize();
                    
                    const ray = new THREE.Raycaster(
                        this.game.camera.position,
                        direction,
                        0,
                        distance
                    );
                    
                    const intersects = ray.intersectObjects(this.game.world.getBlocksInRange(
                        this.game.camera.position,
                        player.position
                    ));
                    
                    if (intersects.length === 0) {
                        this.visiblePlayers.add(playerId);
                    }
                });
                
                // Handle visibility changes
                this.visiblePlayers.forEach(id => {
                    if (!oldVisible.has(id)) {
                        // Player became visible
                        const mesh = this.game.playerMeshes.get(id);
                        if (mesh) mesh.visible = true;
                    }
                });
                
                oldVisible.forEach(id => {
                    if (!this.visiblePlayers.has(id)) {
                        // Player became invisible
                        const mesh = this.game.playerMeshes.get(id);
                        if (mesh) mesh.visible = false;
                    }
                });
            }
        }

        // Initialize game when window loads
        window.addEventListener('load', () => {
            try {
            const game = new Game();
                
                // Handle pointer lock
                const canvas = document.getElementById('gameCanvas');
                
                canvas.addEventListener('click', () => {
                    canvas.requestPointerLock();
                });

                document.addEventListener('pointerlockchange', () => {
                    if (document.pointerLockElement === canvas) {
                        console.log('Pointer lock acquired');
                    } else {
                        console.log('Pointer lock released');
                    }
                });

                document.addEventListener('pointerlockerror', () => {
                    console.error('Pointer lock error');
                });

                window.game = game;
            } catch (error) {
                console.error('Failed to initialize game:', error);
            }
        });

        // Chunk synchronization constants
        const CHUNK_SYNC = {
            OWNERSHIP_TIMEOUT: 30000,  // 30 seconds
            MAX_CONCURRENT_UPDATES: 5,
            DIFF_THRESHOLD: 100,       // Use diff if less than 100 blocks changed
            UPDATE_INTERVAL: 100       // 10 updates per second
        };

        // Using the existing ChunkState class defined above
        // ... existing code ...

        // Add after InstancedBlockManager but before game initialization
        const PERFORMANCE_MONITOR = {
            lastCheck: Date.now(),
            checkInterval: 5000,  // Check every 5 seconds
            fpsThreshold: 30,     // Minimum acceptable FPS
            frames: 0,
            enabled: true,

            tick() {
                if (!this.enabled) return;
                this.frames++;
                
                const now = Date.now();
                if (now - this.lastCheck >= this.checkInterval) {
                    const fps = (this.frames * 1000) / (now - this.lastCheck);
                    
                    if (fps < this.fpsThreshold && INSTANCING.enabled) {
                        console.warn('Performance below threshold, disabling instancing');
                        INSTANCING.enabled = false;
                    }
                    
                    this.frames = 0;
                    this.lastCheck = now;
                }
            }
        };

        // Modify Game update method to include performance monitoring
        const originalGameUpdate = Game.prototype.update;
        Game.prototype.update = function(timestamp) {
            PERFORMANCE_MONITOR.tick();
            return originalGameUpdate.call(this, timestamp);
        };

        // Add safe toggle method
        Game.prototype.toggleInstancing = function(enabled) {
            INSTANCING.enabled = enabled;
            if (enabled) {
                console.log('Attempting to enable instanced rendering...');
                this.instancedRenderer.init();
            } else {
                console.log('Reverting to original rendering...');
                // Clear any existing instanced meshes
                this.instancedRenderer.blockMeshes.forEach(mesh => {
                    this.scene.remove(mesh);
                });
                this.instancedRenderer.blockMeshes.clear();
            }
        };

        // Add after CONFIG but before other code
        const GEOMETRY_OPTIMIZATION = {
            enabled: true,
            sharedGeometry: null,
            sharedAttributes: null,
            initialized: false
        };

        // Add SharedGeometryManager before game class
        class SharedGeometryManager {
            constructor() {
                this.initialized = false;
                this.sharedGeometry = null;
                this.sharedAttributes = null;
            }

            init() {
                if (this.initialized) return;
                try {
                    // Create optimized cube geometry with shared vertices
                    const geometry = new THREE.BoxGeometry(1, 1, 1);
                    
                    // Optimize geometry by merging vertices
                    geometry.mergeVertices();
                    
                    // Store shared data
                    this.sharedGeometry = geometry;
                    this.sharedAttributes = {
                        position: geometry.attributes.position,
                        normal: geometry.attributes.normal,
                        uv: geometry.attributes.uv
                    };
                    
                    this.initialized = true;
                    GEOMETRY_OPTIMIZATION.initialized = true;
                    GEOMETRY_OPTIMIZATION.sharedGeometry = this.sharedGeometry;
                    GEOMETRY_OPTIMIZATION.sharedAttributes = this.sharedAttributes;
                    
                    console.log('Geometry optimization initialized');
                    return true;
                } catch (e) {
                    console.warn('Geometry optimization failed to initialize', e);
                    this.initialized = false;
                    GEOMETRY_OPTIMIZATION.enabled = false;
                    return false;
                }
            }

            createOptimizedBlockGeometry() {
                if (!this.initialized) return new THREE.BoxGeometry(1, 1, 1);
                
                // Create new geometry using shared attributes
                const geometry = new THREE.BufferGeometry();
                
                // Clone and reuse attributes
                geometry.setAttribute('position', this.sharedAttributes.position.clone());
                geometry.setAttribute('normal', this.sharedAttributes.normal.clone());
                geometry.setAttribute('uv', this.sharedAttributes.uv.clone());
                
                return geometry;
            }
        }

        // Modify Game class to use optimized geometry
        const originalGameConstructor = Game.prototype.constructor;
        Game.prototype.constructor = function() {
            // Initialize shared geometry system
            this.sharedGeometry = new SharedGeometryManager();
            this.sharedGeometry.init();
            
            // Call original constructor
            originalGameConstructor.apply(this, arguments);
        };

        // Override block creation to use optimized geometry
        const originalCreateBlock = Game.prototype.createBlock;
        Game.prototype.createBlock = function(type, x, y, z) {
            if (!GEOMETRY_OPTIMIZATION.enabled) {
                return originalCreateBlock.call(this, type, x, y, z);
            }
            
            try {
                const geometry = this.sharedGeometry.createOptimizedBlockGeometry();
                const material = new THREE.MeshLambertMaterial({
                    color: CONFIG.BLOCKS.COLORS[type]
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                return mesh;
            } catch (e) {
                console.warn('Failed to create optimized block, falling back', e);
                return originalCreateBlock.call(this, type, x, y, z);
            }
        };

        // Add memory cleanup method
        Game.prototype.cleanupGeometry = function() {
            if (GEOMETRY_OPTIMIZATION.sharedGeometry) {
                GEOMETRY_OPTIMIZATION.sharedGeometry.dispose();
            }
        };

        // Add after other optimization configs
        const CHUNK_CULLING = {
            enabled: true,
            frustum: new THREE.Frustum(),
            matrix: new THREE.Matrix4(),
            boundingSphere: new THREE.Sphere(),
            culledChunks: new Set(),
            lastUpdate: 0,
            updateInterval: 100  // Update culling every 100ms
        };

        // Add ChunkCullingManager before game class
        class ChunkCullingManager {
            constructor(game) {
                this.game = game;
                this.frustum = CHUNK_CULLING.frustum;
                this.matrix = CHUNK_CULLING.matrix;
                this.boundingSphere = CHUNK_CULLING.boundingSphere;
                this.culledChunks = CHUNK_CULLING.culledChunks;
            }

            updateFrustum() {
                this.matrix.multiplyMatrices(
                    this.game.camera.projectionMatrix,
                    this.game.camera.matrixWorldInverse
                );
                this.frustum.setFromProjectionMatrix(this.matrix);
            }

            isChunkVisible(chunk) {
                // Quick time-based check to avoid too frequent updates
                const now = Date.now();
                if (now - CHUNK_CULLING.lastUpdate > CHUNK_CULLING.updateInterval) {
                    this.updateFrustum();
                    CHUNK_CULLING.lastUpdate = now;
                }

                try {
                    // Calculate chunk center and radius
                    const chunkSize = CONFIG.CHUNK.SIZE;
                    const centerX = chunk.x * chunkSize + chunkSize / 2;
                    const centerZ = chunk.z * chunkSize + chunkSize / 2;
                    const centerY = CONFIG.WORLD.HEIGHT / 2;
                    
                    // Update bounding sphere
                    this.boundingSphere.center.set(centerX, centerY, centerZ);
                    this.boundingSphere.radius = Math.sqrt(
                        Math.pow(chunkSize / 2, 2) + 
                        Math.pow(CONFIG.WORLD.HEIGHT / 2, 2)
                    );

                    // Check if sphere is in frustum
                    const visible = this.frustum.intersectsSphere(this.boundingSphere);
                    
                    // Update culled chunks set
                    if (!visible) {
                        this.culledChunks.add(`${chunk.x},${chunk.z}`);
                    } else {
                        this.culledChunks.delete(`${chunk.x},${chunk.z}`);
                    }

                    return visible;
                } catch (e) {
                    console.warn('Chunk culling check failed, showing chunk', e);
                    return true;  // Show chunk if check fails
                }
            }
        }

        // Modify Game class to use culling
        const originalGameConstructor2 = Game.prototype.constructor;
        Game.prototype.constructor = function() {
            originalGameConstructor2.apply(this, arguments);
            this.cullingManager = new ChunkCullingManager(this);
        };

        // Override chunk rendering to use culling
        const originalRenderChunk = Game.prototype.renderChunk;
        Game.prototype.renderChunk = function(chunk) {
            if (CHUNK_CULLING.enabled) {
                // Skip if chunk is culled
                if (!this.cullingManager.isChunkVisible(chunk)) {
                    return;
                }
            }
            return originalRenderChunk.call(this, chunk);
        };

        // Add culling toggle method
        Game.prototype.toggleChunkCulling = function(enabled) {
            CHUNK_CULLING.enabled = enabled;
            if (!enabled) {
                CHUNK_CULLING.culledChunks.clear();
            }
        };

        // Add after other optimization configs
        const MATERIAL_POOLING = {
            enabled: true,
            materials: new Map(),
            initialized: false
        };

        // Add MaterialPoolManager before game class
        class MaterialPoolManager {
            constructor() {
                this.materials = MATERIAL_POOLING.materials;
                this.initialized = false;
            }

            init() {
                if (this.initialized) return;
                try {
                    // Pre-create materials for all block types
                    Object.entries(CONFIG.BLOCKS.TYPES).forEach(([type, _]) => {
                        if (type === 'AIR') return;
                        this.createMaterial(type);
                    });
                    
                    this.initialized = true;
                    MATERIAL_POOLING.initialized = true;
                    console.log('Material pooling initialized');
                    return true;
                } catch (e) {
                    console.warn('Material pooling failed to initialize', e);
                    this.initialized = false;
                    MATERIAL_POOLING.enabled = false;
                    return false;
                }
            }

            createMaterial(type) {
                if (this.materials.has(type)) return this.materials.get(type);
                
                try {
                    const material = new THREE.MeshLambertMaterial({
                        color: CONFIG.BLOCKS.COLORS[type]
                    });
                    this.materials.set(type, material);
                    return material;
                } catch (e) {
                    console.warn(`Failed to create material for ${type}`, e);
                    return null;
                }
            }

            getMaterial(type) {
                if (!this.initialized || !MATERIAL_POOLING.enabled) {
                    return new THREE.MeshLambertMaterial({
                        color: CONFIG.BLOCKS.COLORS[type]
                    });
                }

                return this.materials.get(type) || this.createMaterial(type);
            }

            cleanup() {
                this.materials.forEach(material => {
                    if (material && material.dispose) {
                        material.dispose();
                    }
                });
                this.materials.clear();
            }
        }

        // Modify Game class to use material pooling
        const originalGameConstructor3 = Game.prototype.constructor;
        Game.prototype.constructor = function() {
            this.materialPool = new MaterialPoolManager();
            this.materialPool.init();
            originalGameConstructor3.apply(this, arguments);
        };

        // Override block creation to use material pooling
        const originalCreateBlock2 = Game.prototype.createBlock;
        Game.prototype.createBlock = function(type, x, y, z) {
            if (!MATERIAL_POOLING.enabled) {
                return originalCreateBlock2.call(this, type, x, y, z);
            }
            
            try {
                const geometry = GEOMETRY_OPTIMIZATION.enabled ? 
                    this.sharedGeometry.createOptimizedBlockGeometry() : 
                    new THREE.BoxGeometry(1, 1, 1);
                    
                const material = this.materialPool.getMaterial(type);
                if (!material) {
                    return originalCreateBlock2.call(this, type, x, y, z);
                }
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                return mesh;
            } catch (e) {
                console.warn('Failed to create block with pooled material, falling back', e);
                return originalCreateBlock2.call(this, type, x, y, z);
            }
        };

        // Add cleanup method
        Game.prototype.cleanupMaterials = function() {
            if (this.materialPool) {
                this.materialPool.cleanup();
            }
        };

        // Add toggle method
        Game.prototype.toggleMaterialPooling = function(enabled) {
            MATERIAL_POOLING.enabled = enabled;
            if (!enabled) {
                this.cleanupMaterials();
            } else {
                this.materialPool.init();
            }
        };

        // Add after other optimization configs
        const OCCLUSION_CULLING = {
            enabled: true,
            initialized: false,
            // Cache results for better performance
            visibilityCache: new Map(),
            // Clear cache periodically
            lastCacheClear: Date.now(),
            cacheClearInterval: 5000  // Clear every 5 seconds
        };

        // Add OcclusionManager before game class
        class OcclusionManager {
            constructor(game) {
                this.game = game;
                this.initialized = false;
            }

            init() {
                if (this.initialized) return;
                try {
                    this.initialized = true;
                    OCCLUSION_CULLING.initialized = true;
                    console.log('Occlusion culling initialized');
                    return true;
                } catch (e) {
                    console.warn('Occlusion culling failed to initialize', e);
                    this.initialized = false;
                    OCCLUSION_CULLING.enabled = false;
                    return false;
                }
            }

            isBlockVisible(chunk, x, y, z) {
                if (!OCCLUSION_CULLING.enabled || !this.initialized) {
                    return true;
                }

                try {
                    // Check cache first
                    const cacheKey = `${chunk.x},${chunk.z},${x},${y},${z}`;
                    if (OCCLUSION_CULLING.visibilityCache.has(cacheKey)) {
                        return OCCLUSION_CULLING.visibilityCache.get(cacheKey);
                    }

                    // Clear cache periodically
                    const now = Date.now();
                    if (now - OCCLUSION_CULLING.lastCacheClear > OCCLUSION_CULLING.cacheClearInterval) {
                        OCCLUSION_CULLING.visibilityCache.clear();
                        OCCLUSION_CULLING.lastCacheClear = now;
                    }

                    // Check if block is completely surrounded
                    const surrounded = this.isBlockSurrounded(chunk, x, y, z);
                    
                    // Cache the result
                    OCCLUSION_CULLING.visibilityCache.set(cacheKey, !surrounded);
                    
                    return !surrounded;
                } catch (e) {
                    console.warn('Block visibility check failed, showing block', e);
                    return true;
                }
            }

            isBlockSurrounded(chunk, x, y, z) {
                // Check all 6 sides
                const sides = [
                    [x+1, y, z], [x-1, y, z],
                    [x, y+1, z], [x, y-1, z],
                    [x, y, z+1], [x, y, z-1]
                ];

                return sides.every(([sx, sy, sz]) => {
                    // Get block at position
                    let block;
                    if (sx < 0 || sx >= CONFIG.CHUNK.SIZE || sz < 0 || sz >= CONFIG.CHUNK.SIZE) {
                        // Block is in another chunk
                        const newChunkX = chunk.x + Math.floor(sx / CONFIG.CHUNK.SIZE);
                        const newChunkZ = chunk.z + Math.floor(sz / CONFIG.CHUNK.SIZE);
                        const newChunk = this.game.getChunk(newChunkX, newChunkZ);
                        if (!newChunk) return false;
                        
                        const localX = ((sx % CONFIG.CHUNK.SIZE) + CONFIG.CHUNK.SIZE) % CONFIG.CHUNK.SIZE;
                        const localZ = ((sz % CONFIG.CHUNK.SIZE) + CONFIG.CHUNK.SIZE) % CONFIG.CHUNK.SIZE;
                        block = newChunk.getBlock(localX, sy, localZ);
                    } else {
                        block = chunk.getBlock(sx, sy, sz);
                    }
                    
                    return block !== CONFIG.BLOCKS.TYPES.AIR;
                });
            }
        }

        // Modify Game class to use occlusion culling
        const originalGameConstructor4 = Game.prototype.constructor;
        Game.prototype.constructor = function() {
            this.occlusionManager = new OcclusionManager(this);
            this.occlusionManager.init();
            originalGameConstructor4.apply(this, arguments);
        };

        // Override block creation to use occlusion culling
        const originalCreateBlock3 = Game.prototype.createBlock;
        Game.prototype.createBlock = function(type, x, y, z, chunk) {
            if (!chunk || !OCCLUSION_CULLING.enabled) {
                return originalCreateBlock3.call(this, type, x, y, z);
            }

            // Skip if block is completely hidden
            if (!this.occlusionManager.isBlockVisible(chunk, x, y, z)) {
                return null;
            }

            return originalCreateBlock3.call(this, type, x, y, z);
        };

        // Add toggle method
        Game.prototype.toggleOcclusionCulling = function(enabled) {
            OCCLUSION_CULLING.enabled = enabled;
            if (!enabled) {
                OCCLUSION_CULLING.visibilityCache.clear();
            }
        };

        // Add after other optimization configs
        const TEXTURE_ATLAS = {
            enabled: true,
            initialized: false,
            atlas: null,
            uvCache: new Map(),
            size: 512  // Atlas texture size
        };

        // Add TextureAtlasManager before game class
        class TextureAtlasManager {
            constructor(game) {
                this.game = game;
                this.initialized = false;
                this.blockColors = CONFIG.BLOCKS.COLORS;
            }

            init() {
                if (this.initialized) return;
                try {
                    // Create atlas canvas
                    const canvas = document.createElement('canvas');
                    canvas.width = TEXTURE_ATLAS.size;
                    canvas.height = TEXTURE_ATLAS.size;
                    const ctx = canvas.getContext('2d');

                    // Calculate block texture size
                    const blockTypes = Object.keys(this.blockColors).filter(type => type !== 'AIR');
                    const textureSide = Math.ceil(Math.sqrt(blockTypes.length));
                    const textureSize = TEXTURE_ATLAS.size / textureSide;

                    // Generate textures for each block type
                    blockTypes.forEach((type, index) => {
                        const x = (index % textureSide) * textureSize;
                        const y = Math.floor(index / textureSide) * textureSize;

                        // Create block texture
                        this.generateBlockTexture(ctx, x, y, textureSize, type);

                        // Store UV coordinates
                        const uvs = {
                            u1: x / TEXTURE_ATLAS.size,
                            v1: y / TEXTURE_ATLAS.size,
                            u2: (x + textureSize) / TEXTURE_ATLAS.size,
                            v2: (y + textureSize) / TEXTURE_ATLAS.size
                        };
                        TEXTURE_ATLAS.uvCache.set(type, uvs);
                    });

                    // Create Three.js texture
                    const texture = new THREE.CanvasTexture(canvas);
                    texture.magFilter = THREE.NearestFilter;
                    texture.minFilter = THREE.NearestFilter;
                    TEXTURE_ATLAS.atlas = texture;

                    this.initialized = true;
                    TEXTURE_ATLAS.initialized = true;
                    console.log('Texture atlas initialized');
                    return true;
                } catch (e) {
                    console.warn('Texture atlas failed to initialize', e);
                    this.initialized = false;
                    TEXTURE_ATLAS.enabled = false;
                    return false;
                }
            }

            generateBlockTexture(ctx, x, y, size, type) {
                const color = this.blockColors[type];
                
                // Fill base color
                ctx.fillStyle = color;
                ctx.fillRect(x, y, size, size);

                // Add some texture variation
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                for (let i = 0; i < 5; i++) {
                    const px = x + Math.random() * size;
                    const py = y + Math.random() * size;
                    const s = size * 0.2;
                    ctx.fillRect(px, py, s, s);
                }

                // Add highlight
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(x, y, size * 0.3, size * 0.3);
            }

            getBlockMaterial(type) {
                if (!TEXTURE_ATLAS.enabled || !this.initialized) {
                    return new THREE.MeshLambertMaterial({
                        color: this.blockColors[type]
                    });
                }

                try {
                    const uvs = TEXTURE_ATLAS.uvCache.get(type);
                    if (!uvs) throw new Error('UV coordinates not found');

                    return new THREE.MeshLambertMaterial({
                        map: TEXTURE_ATLAS.atlas,
                        color: 0xFFFFFF,
                        uvTransform: new THREE.Matrix3().setUvTransform(
                            uvs.u1, uvs.v1,
                            uvs.u2 - uvs.u1, uvs.v2 - uvs.v1,
                            0, 0, 0
                        )
                    });
                } catch (e) {
                    console.warn('Failed to create textured material, falling back', e);
                    return new THREE.MeshLambertMaterial({
                        color: this.blockColors[type]
                    });
                }
            }
        }

        // Modify Game class to use texture atlas
        const originalGameConstructor5 = Game.prototype.constructor;
        Game.prototype.constructor = function() {
            this.textureAtlas = new TextureAtlasManager(this);
            this.textureAtlas.init();
            originalGameConstructor5.apply(this, arguments);
        };

        // Override material creation in MaterialPoolManager
        MaterialPoolManager.prototype.createMaterial = function(type) {
            if (this.materials.has(type)) return this.materials.get(type);
            
            try {
                const material = this.game.textureAtlas.getBlockMaterial(type);
                this.materials.set(type, material);
                return material;
            } catch (e) {
                console.warn(`Failed to create material for ${type}`, e);
                return null;
            }
        };

        // Add toggle method
        Game.prototype.toggleTextureAtlas = function(enabled) {
            TEXTURE_ATLAS.enabled = enabled;
            if (!enabled) {
                // Recreate all materials without textures
                this.materialPool.cleanup();
                this.materialPool.init();
            }
        };

        // Add after other optimization configs
        const MESH_MERGING = {
            enabled: true,
            initialized: false,
            mergeSize: 4,  // Size of merge groups (4x4x4 blocks)
            meshCache: new Map(),
            lastCleanup: Date.now(),
            cleanupInterval: 10000  // Cleanup every 10 seconds
        };

        // Add MeshMergeManager before game class
        class MeshMergeManager {
            constructor(game) {
                this.game = game;
                this.initialized = false;
                this.meshCache = MESH_MERGING.meshCache;
            }

            init() {
                if (this.initialized) return;
                try {
                    this.initialized = true;
                    MESH_MERGING.initialized = true;
                    console.log('Mesh merging initialized');
                    return true;
                } catch (e) {
                    console.warn('Mesh merging failed to initialize', e);
                    this.initialized = false;
                    MESH_MERGING.enabled = false;
                    return false;
                }
            }

            getMergeGroup(chunk, x, y, z) {
                const groupX = Math.floor(x / MESH_MERGING.mergeSize);
                const groupY = Math.floor(y / MESH_MERGING.mergeSize);
                const groupZ = Math.floor(z / MESH_MERGING.mergeSize);
                return `${chunk.x},${chunk.z},${groupX},${groupY},${groupZ}`;
            }

            createMergedMesh(chunk, groupId) {
                const [chunkX, chunkZ, groupX, groupY, groupZ] = groupId.split(',').map(Number);
                const startX = groupX * MESH_MERGING.mergeSize;
                const startY = groupY * MESH_MERGING.mergeSize;
                const startZ = groupZ * MESH_MERGING.mergeSize;
                
                // Create geometry for the merged mesh
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const normals = [];
                const uvs = [];
                
                // Collect block data in this group
                for (let x = 0; x < MESH_MERGING.mergeSize; x++) {
                    for (let y = 0; y < MESH_MERGING.mergeSize; y++) {
                        for (let z = 0; z < MESH_MERGING.mergeSize; z++) {
                            const worldX = startX + x;
                            const worldY = startY + y;
                            const worldZ = startZ + z;
                            
                            if (worldX >= CONFIG.CHUNK.SIZE || worldZ >= CONFIG.CHUNK.SIZE) continue;
                            
                            const blockType = chunk.getBlock(worldX, worldY, worldZ);
                            if (blockType === CONFIG.BLOCKS.TYPES.AIR) continue;
                            
                            // Add block vertices to merged mesh
                            this.addBlockToMergedMesh(
                                positions, normals, uvs,
                                worldX, worldY, worldZ,
                                blockType
                            );
                        }
                    }
                }
                
                // Create merged mesh
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                
                // Use existing material from material pool
                const material = this.game.materialPool.getMaterial(
                    Object.keys(CONFIG.BLOCKS.TYPES)[1]  // Use first non-air block type
                );
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(
                    chunk.x * CONFIG.CHUNK.SIZE,
                    0,
                    chunk.z * CONFIG.CHUNK.SIZE
                );
                
                return mesh;
            }

            addBlockToMergedMesh(positions, normals, uvs, x, y, z, type) {
                // Cube vertices
                const verts = [
                    // Front face
                    x, y, z+1,    x+1, y, z+1,    x+1, y+1, z+1,    x, y+1, z+1,
                    // Back face
                    x+1, y, z,    x, y, z,        x, y+1, z,        x+1, y+1, z,
                    // Top face
                    x, y+1, z,    x+1, y+1, z,    x+1, y+1, z+1,    x, y+1, z+1,
                    // Bottom face
                    x, y, z,      x+1, y, z,      x+1, y, z+1,      x, y, z+1,
                    // Right face
                    x+1, y, z,    x+1, y, z+1,    x+1, y+1, z+1,    x+1, y+1, z,
                    // Left face
                    x, y, z+1,    x, y, z,        x, y+1, z,        x, y+1, z+1,
                ];
                
                // Add vertices
                for (let i = 0; i < verts.length; i += 3) {
                    positions.push(verts[i], verts[i+1], verts[i+2]);
                }
                
                // Add normals
                const faceNormals = [
                    0,0,1,  0,0,1,  0,0,1,  0,0,1,    // Front
                    0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1,   // Back
                    0,1,0,  0,1,0,  0,1,0,  0,1,0,    // Top
                    0,-1,0, 0,-1,0, 0,-1,0, 0,-1,0,   // Bottom
                    1,0,0,  1,0,0,  1,0,0,  1,0,0,    // Right
                    -1,0,0, -1,0,0, -1,0,0, -1,0,0    // Left
                ];
                normals.push(...faceNormals);
                
                // Add UVs (if using texture atlas)
                if (TEXTURE_ATLAS.enabled) {
                    const blockUVs = TEXTURE_ATLAS.uvCache.get(
                        Object.keys(CONFIG.BLOCKS.TYPES)[type]
                    );
                    if (blockUVs) {
                        for (let i = 0; i < 6; i++) {  // 6 faces
                            uvs.push(
                                blockUVs.u1, blockUVs.v1,
                                blockUVs.u2, blockUVs.v1,
                                blockUVs.u2, blockUVs.v2,
                                blockUVs.u1, blockUVs.v2
                            );
                        }
                    }
                } else {
                    // Default UVs if no texture atlas
                    const defaultUVs = [
                        0,0, 1,0, 1,1, 0,1,  // Front
                        0,0, 1,0, 1,1, 0,1,  // Back
                        0,0, 1,0, 1,1, 0,1,  // Top
                        0,0, 1,0, 1,1, 0,1,  // Bottom
                        0,0, 1,0, 1,1, 0,1,  // Right
                        0,0, 1,0, 1,1, 0,1   // Left
                    ];
                    uvs.push(...defaultUVs);
                }
            }

            updateChunkMeshes(chunk) {
                if (!MESH_MERGING.enabled || !this.initialized) return false;
                
                try {
                    // Cleanup old meshes periodically
                    const now = Date.now();
                    if (now - MESH_MERGING.lastCleanup > MESH_MERGING.cleanupInterval) {
                        this.cleanup();
                        MESH_MERGING.lastCleanup = now;
                    }
                    
                    // Track which groups we've updated
                    const updatedGroups = new Set();
                    
                    // Process each block in chunk
                    chunk.blocks.forEach((type, key) => {
                        if (type === CONFIG.BLOCKS.TYPES.AIR) return;
                        
                        const [x, y, z] = key.split(',').map(Number);
                        const groupId = this.getMergeGroup(chunk, x, y, z);
                        
                        if (!updatedGroups.has(groupId)) {
                            // Remove old mesh if it exists
                            const oldMesh = this.meshCache.get(groupId);
                            if (oldMesh) {
                                this.game.scene.remove(oldMesh);
                                oldMesh.geometry.dispose();
                            }
                            
                            // Create and add new merged mesh
                            const newMesh = this.createMergedMesh(chunk, groupId);
                            this.game.scene.add(newMesh);
                            this.meshCache.set(groupId, newMesh);
                            
                            updatedGroups.add(groupId);
                        }
                    });
                    
                    return true;
                } catch (e) {
                    console.warn('Failed to update merged meshes', e);
                    return false;
                }
            }

            cleanup() {
                // Remove old meshes
                this.meshCache.forEach((mesh, groupId) => {
                    const [chunkX, chunkZ] = groupId.split(',').map(Number);
                    if (!this.game.getChunk(chunkX, chunkZ)) {
                        this.game.scene.remove(mesh);
                        mesh.geometry.dispose();
                        this.meshCache.delete(groupId);
                    }
                });
            }
        }

        // Modify Game class to use mesh merging
        const originalGameConstructor6 = Game.prototype.constructor;
        Game.prototype.constructor = function() {
            this.meshMerger = new MeshMergeManager(this);
            this.meshMerger.init();
            originalGameConstructor6.apply(this, arguments);
        };

        // Override chunk rendering to use mesh merging
        const originalRenderChunk2 = Game.prototype.renderChunk;
        Game.prototype.renderChunk = function(chunk) {
            if (MESH_MERGING.enabled) {
                // Try mesh merging first
                if (this.meshMerger.updateChunkMeshes(chunk)) {
                    return;
                }
            }
            return originalRenderChunk2.call(this, chunk);
        };

        // Add toggle method
        Game.prototype.toggleMeshMerging = function(enabled) {
            MESH_MERGING.enabled = enabled;
            if (!enabled) {
                // Clean up merged meshes
                this.meshMerger.meshCache.forEach((mesh) => {
                    this.scene.remove(mesh);
                    mesh.geometry.dispose();
                });
                this.meshMerger.meshCache.clear();
                
                // Rerender all chunks
                this.chunks.forEach(chunk => {
                    this.renderChunk(chunk);
                });
            }
        };

        // Add after other optimization configs
        const LOD = {
            enabled: true,
            initialized: false,
            levels: [
                { distance: 32, scale: 1 },    // Full detail
                { distance: 64, scale: 2 },    // Half detail
                { distance: 128, scale: 4 },   // Quarter detail
                { distance: 256, scale: 8 }    // Eighth detail
            ],
            meshCache: new Map(),
            lastCleanup: Date.now(),
            cleanupInterval: 10000
        };

        // Add LODManager class
        class LODManager {
            constructor(game) {
                this.game = game;
                this.initialized = false;
                this.meshCache = LOD.meshCache;
            }

            init() {
                if (this.initialized) return;
                try {
                    this.initialized = true;
                    LOD.initialized = true;
                    return true;
                } catch (e) {
                    console.warn('LOD system failed to initialize', e);
                    this.initialized = false;
                    LOD.enabled = false;
                    return false;
                }
            }

            getChunkDistance(chunk) {
                const playerX = Math.floor(this.game.camera.position.x / CONFIG.CHUNK.SIZE);
                const playerZ = Math.floor(this.game.camera.position.z / CONFIG.CHUNK.SIZE);
                return Math.max(
                    Math.abs(chunk.x - playerX),
                    Math.abs(chunk.z - playerZ)
                );
            }

            getLODLevel(chunk) {
                const distance = this.getChunkDistance(chunk);
                for (let i = LOD.levels.length - 1; i >= 0; i--) {
                    if (distance >= LOD.levels[i].distance) {
                        return LOD.levels[i];
                    }
                }
                return LOD.levels[0];
            }

            updateChunkLOD(chunk) {
                if (!LOD.enabled || !this.initialized) return false; 
                
                const lodLevel = this.getLODLevel(chunk);
                if (lodLevel.scale === 1) return false;  // Use original rendering for full detail
                
                try {
                    const scale = lodLevel.scale;
                    const geometry = new THREE.BufferGeometry();
                    const positions = [];
                    const colors = [];
                    
                    // Sample blocks at lower resolution
                    for (let x = 0; x < CONFIG.CHUNK.SIZE; x += scale) {
                        for (let y = 0; y < CONFIG.WORLD.HEIGHT; y += scale) {
                            for (let z = 0; z < CONFIG.CHUNK.SIZE; z += scale) {
                                const blockType = chunk.getBlock(x, y, z);
                                if (blockType === CONFIG.BLOCKS.TYPES.AIR) continue;
                                
                                const color = new THREE.Color(CONFIG.BLOCKS.COLORS[
                                    Object.keys(CONFIG.BLOCKS.TYPES)[blockType]
                                ]);
                                
                                // Add scaled block
                                this.addScaledBlock(positions, colors, x, y, z, scale, color);
                            }
                        }
                    }
                    
                    if (positions.length === 0) return false;
                    
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                    
                    const material = new THREE.MeshBasicMaterial({ 
                        vertexColors: true,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(
                        chunk.x * CONFIG.CHUNK.SIZE,
                        0,
                        chunk.z * CONFIG.CHUNK.SIZE
                    );
                    
                    // Update cache
                    const key = `${chunk.x},${chunk.z}`;
                    const oldMesh = this.meshCache.get(key);
                    if (oldMesh) {
                        this.game.scene.remove(oldMesh);
                        oldMesh.geometry.dispose();
                    }
                    
                    this.game.scene.add(mesh);
                    this.meshCache.set(key, mesh);
                    
                    return true;
                } catch (e) {
                    console.warn('Failed to update chunk LOD', e);
                    return false;
                }
            }

            addScaledBlock(positions, colors, x, y, z, scale, color) {
                // Simplified block geometry for distant chunks
                const vertices = [
                    // Top
                    x, y+scale, z,       x+scale, y+scale, z,
                    x+scale, y+scale, z+scale,   x, y+scale, z+scale,
                    // Sides
                    x, y, z,       x, y+scale, z,
                    x+scale, y, z, x+scale, y+scale, z,
                    x, y, z+scale, x, y+scale, z+scale,
                    x+scale, y, z+scale, x+scale, y+scale, z+scale
                ];
                
                for (let i = 0; i < vertices.length; i += 3) {
                    positions.push(vertices[i], vertices[i+1], vertices[i+2]);
                    colors.push(color.r, color.g, color.b);
                }
            }

            cleanup() {
                const now = Date.now();
                if (now - LOD.lastCleanup > LOD.cleanupInterval) {
                    this.meshCache.forEach((mesh, key) => {
                        const [x, z] = key.split(',').map(Number);
                        if (!this.game.getChunk(x, z)) {
                            this.game.scene.remove(mesh);
                            mesh.geometry.dispose();
                            this.meshCache.delete(key);
                        }
                    });
                    LOD.lastCleanup = now;
                }
            }
        }

        // Modify Game class to use LOD
        const originalGameConstructor7 = Game.prototype.constructor;
        Game.prototype.constructor = function() {
            this.lodManager = new LODManager(this);
            this.lodManager.init();
            originalGameConstructor7.apply(this, arguments);
        };

        // Override chunk rendering to use LOD
        const originalRenderChunk3 = Game.prototype.renderChunk;
        Game.prototype.renderChunk = function(chunk) {
            if (LOD.enabled && this.lodManager.updateChunkLOD(chunk)) {
                return;  // LOD handled the chunk
            }
            return originalRenderChunk3.call(this, chunk);
        };

        // Add toggle method
        Game.prototype.toggleLOD = function(enabled) {
            LOD.enabled = enabled;
            if (!enabled) {
                this.lodManager.meshCache.forEach(mesh => {
                    this.scene.remove(mesh);
                    mesh.geometry.dispose();
                });
                this.lodManager.meshCache.clear();
                this.chunks.forEach(chunk => this.renderChunk(chunk));
            }
        };

        // Add after other optimization configs
        const CHUNK_PREFETCH = {
            enabled: true,
            initialized: false,
            predictionDistance: 3,  // How many chunks ahead to predict
            historyLength: 10,     // How many positions to keep for movement prediction
            moveHistory: [],       // Store recent positions
            lastUpdate: Date.now(),
            updateInterval: 500    // Update predictions every 500ms
        };

        // Add ChunkPrefetchManager before game class
        class ChunkPrefetchManager {
            constructor(game) {
                this.game = game;
                this.initialized = false;
                this.moveHistory = CHUNK_PREFETCH.moveHistory;
                this.priorityChunks = new Set();
            }

            init() {
                if (this.initialized) return;
                try {
                    this.initialized = true;
                    CHUNK_PREFETCH.initialized = true;
                    console.log('Chunk prefetching initialized');
                    return true;
                } catch (e) {
                    console.warn('Chunk prefetching failed to initialize', e);
                    this.initialized = false;
                    CHUNK_PREFETCH.enabled = false;
                    return false;
                }
            }

            update() {
                if (!CHUNK_PREFETCH.enabled || !this.initialized) return;

                try {
                    const now = Date.now();
                    if (now - CHUNK_PREFETCH.lastUpdate < CHUNK_PREFETCH.updateInterval) {
                        return;
                    }
                    CHUNK_PREFETCH.lastUpdate = now;

                    // Update position history
                    const currentPos = {
                        x: this.game.camera.position.x,
                        z: this.game.camera.position.z,
                        time: now
                    };
                    
                    this.moveHistory.push(currentPos);
                    if (this.moveHistory.length > CHUNK_PREFETCH.historyLength) {
                        this.moveHistory.shift();
                    }

                    // Calculate movement vector
                    const moveVector = this.calculateMoveVector();
                    
                    // Get look direction
                    const lookVector = new THREE.Vector3();
                    this.game.camera.getWorldDirection(lookVector);

                    // Combine movement and look directions
                    const predictionVector = new THREE.Vector3(
                        moveVector.x * 0.7 + lookVector.x * 0.3,
                        0,
                        moveVector.z * 0.7 + lookVector.z * 0.3
                    ).normalize();

                    // Get chunks to prefetch
                    this.updatePriorityChunks(predictionVector);
                    
                    // Trigger chunk loading
                    this.loadPriorityChunks();

                } catch (e) {
                    console.warn('Chunk prefetch update failed', e);
                }
            }

            calculateMoveVector() {
                if (this.moveHistory.length < 2) {
                    return new THREE.Vector3();
                }

                const latest = this.moveHistory[this.moveHistory.length - 1];
                const oldest = this.moveHistory[0];
                const deltaTime = latest.time - oldest.time;

                if (deltaTime === 0) return new THREE.Vector3();

                return new THREE.Vector3(
                    (latest.x - oldest.x) / deltaTime,
                    0,
                    (latest.z - oldest.z) / deltaTime
                );
            }

            updatePriorityChunks(direction) {
                this.priorityChunks.clear();

                const currentChunkX = Math.floor(this.game.camera.position.x / CONFIG.CHUNK.SIZE);
                const currentChunkZ = Math.floor(this.game.camera.position.z / CONFIG.CHUNK.SIZE);

                for (let i = 1; i <= CHUNK_PREFETCH.predictionDistance; i++) {
                    const distance = i * CONFIG.CHUNK.SIZE;
                    const targetX = this.game.camera.position.x + direction.x * distance;
                    const targetZ = this.game.camera.position.z + direction.z * distance;

                    const chunkX = Math.floor(targetX / CONFIG.CHUNK.SIZE);
                    const chunkZ = Math.floor(targetZ / CONFIG.CHUNK.SIZE);

                    // Add target chunk and surrounding chunks
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dz = -1; dz <= 1; dz++) {
                            this.priorityChunks.add(`${chunkX + dx},${chunkZ + dz}`);
                        }
                    }
                }
            }

            loadPriorityChunks() {
                this.priorityChunks.forEach(key => {
                    const [x, z] = key.split(',').map(Number);
                    if (!this.game.getChunk(x, z)) {
                        this.game.loadChunk(x, z, true);  // true for high priority
                    }
                });
            }
        }

        // Modify Game class to use chunk prefetching
        const originalGameConstructor8 = Game.prototype.constructor;
        Game.prototype.constructor = function() {
            this.prefetchManager = new ChunkPrefetchManager(this);
            this.prefetchManager.init();
            originalGameConstructor8.apply(this, arguments);
        };

        // Modify update loop to include prefetching
        const originalGameUpdate2 = Game.prototype.update;
        Game.prototype.update = function(timestamp) {
            if (this.prefetchManager) {
                this.prefetchManager.update();
            }
            return originalGameUpdate2.call(this, timestamp);
        };

        // Add toggle method
        Game.prototype.toggleChunkPrefetch = function(enabled) {
            CHUNK_PREFETCH.enabled = enabled;
            if (!enabled) {
                CHUNK_PREFETCH.moveHistory = [];
                this.prefetchManager.priorityChunks.clear();
            }
        };

        // Modify chunk loading to support priorities
        const originalLoadChunk = Game.prototype.loadChunk;
        Game.prototype.loadChunk = function(x, z, highPriority = false) {
            if (highPriority) {
                // Load high priority chunks immediately
                return originalLoadChunk.call(this, x, z);
            }
            
            // Check if this is a priority chunk
            if (this.prefetchManager && 
                this.prefetchManager.priorityChunks.has(`${x},${z}`)) {
                return originalLoadChunk.call(this, x, z);
            }
            
            // Normal priority loading
            return originalLoadChunk.call(this, x, z);
        };

        // Add after other optimization configs
        const FRUSTUM_CACHE = {
            enabled: true,
            initialized: false,
            cache: new Map(),
            lastCameraPosition: new THREE.Vector3(),
            lastCameraRotation: new THREE.Euler(),
            cameraThreshold: 0.1,  // How much camera needs to move to invalidate cache
            rotationThreshold: 0.01,  // How much rotation needed to invalidate cache
            maxCacheSize: 1000,
            lastCleanup: Date.now(),
            cleanupInterval: 5000  // Cleanup every 5 seconds
        };

        // Add FrustumCacheManager before game class
        class FrustumCacheManager {
            constructor(game) {
                this.game = game;
                this.initialized = false;
                this.cache = FRUSTUM_CACHE.cache;
                this.frustum = new THREE.Frustum();
                this.projScreenMatrix = new THREE.Matrix4();
                this.lastPosition = FRUSTUM_CACHE.lastCameraPosition.clone();
                this.lastRotation = FRUSTUM_CACHE.lastCameraRotation.clone();
            }

            init() {
                if (this.initialized) return;
                try {
                    this.initialized = true;
                    FRUSTUM_CACHE.initialized = true;
                    console.log('Frustum caching initialized');
                    return true;
                } catch (e) {
                    console.warn('Frustum caching failed to initialize', e);
                    this.initialized = false;
                    FRUSTUM_CACHE.enabled = false;
                    return false;
                }
            }

            shouldUpdateCache() {
                const camera = this.game.camera;
                
                // Check position change
                const positionDelta = camera.position.distanceTo(this.lastPosition);
                if (positionDelta > FRUSTUM_CACHE.cameraThreshold) {
                    return true;
                }
                
                // Check rotation change
                const rotationDelta = Math.max(
                    Math.abs(camera.rotation.x - this.lastRotation.x),
                    Math.abs(camera.rotation.y - this.lastRotation.y),
                    Math.abs(camera.rotation.z - this.lastRotation.z)
                );
                if (rotationDelta > FRUSTUM_CACHE.rotationThreshold) {
                    return true;
                }
                
                return false;
            }

            updateCache() {
                // Update camera state
                this.lastPosition.copy(this.game.camera.position);
                this.lastRotation.copy(this.game.camera.rotation);
                
                // Update frustum
                this.projScreenMatrix.multiplyMatrices(
                    this.game.camera.projectionMatrix,
                    this.game.camera.matrixWorldInverse
                );
                this.frustum.setFromProjectionMatrix(this.projScreenMatrix);
                
                // Clear old cache
                this.cache.clear();
            }

            isChunkVisible(chunk) {
                if (!FRUSTUM_CACHE.enabled || !this.initialized) {
                    return this.checkChunkVisibility(chunk);
                }

                try {
                    // Check if we need to update cache
                    if (this.shouldUpdateCache()) {
                        this.updateCache();
                    }

                    // Check cache
                    const key = `${chunk.x},${chunk.z}`;
                    if (this.cache.has(key)) {
                        return this.cache.get(key);
                    }

                    // Calculate visibility
                    const isVisible = this.checkChunkVisibility(chunk);
                    this.cache.set(key, isVisible);

                    // Cleanup cache if too large
                    if (this.cache.size > FRUSTUM_CACHE.maxCacheSize) {
                        this.cleanupCache();
                    }

                    return isVisible;
                } catch (e) {
                    console.warn('Frustum cache check failed', e);
                    return true;  // Show chunk if check fails
                }
            }

            checkChunkVisibility(chunk) {
                // Create chunk bounds
                const chunkSize = CONFIG.CHUNK.SIZE;
                const worldX = chunk.x * chunkSize;
                const worldZ = chunk.z * chunkSize;
                
                // Create bounding box for chunk
                const box = new THREE.Box3(
                    new THREE.Vector3(
                        worldX,
                        0,
                        worldZ
                    ),
                    new THREE.Vector3(
                        worldX + chunkSize,
                        CONFIG.WORLD.HEIGHT,
                        worldZ + chunkSize
                    )
                );
                
                // Check if box intersects frustum
                return this.frustum.intersectsBox(box);
            }

            cleanupCache() {
                const now = Date.now();
                if (now - FRUSTUM_CACHE.lastCleanup < FRUSTUM_CACHE.cleanupInterval) {
                    return;
                }
                
                // Clear cache and update timestamp
                this.cache.clear();
                FRUSTUM_CACHE.lastCleanup = now;
            }
        }

        // Modify Game class to use frustum caching
        const originalGameConstructor9 = Game.prototype.constructor;
        Game.prototype.constructor = function() {
            this.frustumCache = new FrustumCacheManager(this);
            this.frustumCache.init();
            originalGameConstructor9.apply(this, arguments);
        };

        // Override chunk visibility check
        Game.prototype.isChunkVisible = function(chunk) {
            return this.frustumCache.isChunkVisible(chunk);
        };

        // Add toggle method
        Game.prototype.toggleFrustumCache = function(enabled) {
            FRUSTUM_CACHE.enabled = enabled;
            if (!enabled) {
                this.frustumCache.cache.clear();
            }
        };

        // Add optimized shaders
        const OPTIMIZED_SHADERS = {
            enabled: true,
            initialized: false,
            
            // Vertex shader with optimized transforms
            vertexShader: `
                attribute vec3 position;
                attribute vec3 normal;
                attribute vec2 uv;
                attribute vec3 color;
                
                uniform mat4 modelViewMatrix;
                uniform mat4 projectionMatrix;
                
                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec3 vColor;
                varying float vFog;
                
                void main() {
                    // Optimized position calculation
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    
                    // Pass varyings
                    vUv = uv;
                    vNormal = normalize(normal);
                    vColor = color;
                    
                    // Optimized fog calculation
                    float fogNear = 32.0;
                    float fogFar = 96.0;
                    vFog = 1.0 - clamp((fogFar - length(mvPosition.xyz)) / (fogFar - fogNear), 0.0, 1.0);
                }
            `,
            
            // Fragment shader with optimized lighting
            fragmentShader: `
                uniform sampler2D map;
                uniform vec3 sunDirection;
                uniform vec3 ambientLight;
                
                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec3 vColor;
                varying float vFog;
                
                void main() {
                    // Optimized texture lookup
                    vec4 texColor = texture2D(map, vUv);
                    
                    // Optimized lighting calculation
                    float sunLight = max(dot(vNormal, sunDirection), 0.0);
                    vec3 light = ambientLight + sunLight * vec3(1.0);
                    
                    // Combine colors
                    vec3 finalColor = mix(
                        vColor * texColor.rgb * light,
                        vec3(0.6, 0.8, 1.0),  // Sky color
                        vFog
                    );
                    
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `
        };

        // Add ShaderManager class
        class ShaderManager {
            constructor(game) {
                this.game = game;
                this.initialized = false;
                this.materials = new Map();
                this.uniforms = {
                    sunDirection: { value: new THREE.Vector3(0.5, 1.0, 0.3).normalize() },
                    ambientLight: { value: new THREE.Vector3(0.3, 0.3, 0.3) }
                };
            }

            init() {
                if (this.initialized) return;
                try {
                    // Create base shader material
                    const shaderMaterial = new THREE.ShaderMaterial({
                        uniforms: this.uniforms,
                        vertexShader: OPTIMIZED_SHADERS.vertexShader,
                        fragmentShader: OPTIMIZED_SHADERS.fragmentShader,
                        vertexColors: true,
                        fog: false  // We handle fog in shader
                    });
                    
                    this.initialized = true;
                    OPTIMIZED_SHADERS.initialized = true;
                    console.log('Shader optimization initialized');
                    return true;
                } catch (e) {
                    console.warn('Shader optimization failed to initialize', e);
                    this.initialized = false;
                    OPTIMIZED_SHADERS.enabled = false;
                    return false;
                }
            }

            createMaterial(type) {
                if (!OPTIMIZED_SHADERS.enabled || !this.initialized) {
                    return new THREE.MeshLambertMaterial({
                        color: CONFIG.BLOCKS.COLORS[type]
                    });
                }

                try {
                    // Create optimized material
                    const material = new THREE.ShaderMaterial({
                        uniforms: {
                            ...this.uniforms,
                            map: { 
                                value: TEXTURE_ATLAS.enabled ? 
                                    TEXTURE_ATLAS.atlas : 
                                    null 
                            }
                        },
                        vertexShader: OPTIMIZED_SHADERS.vertexShader,
                        fragmentShader: OPTIMIZED_SHADERS.fragmentShader,
                        vertexColors: true,
                        transparent: false
                    });

                    return material;
                } catch (e) {
                    console.warn('Failed to create optimized material', e);
                    return new THREE.MeshLambertMaterial({
                        color: CONFIG.BLOCKS.COLORS[type]
                    });
                }
            }

            updateLighting() {
                // Update sun position based on time
                const time = Date.now() * 0.0001;
                this.uniforms.sunDirection.value.set(
                    Math.sin(time) * 0.5,
                    Math.cos(time * 0.5) * 0.5 + 0.5,
                    Math.cos(time) * 0.5
                ).normalize();
            }
        }

        // Modify Game class to use shader optimization
        const originalGameConstructor10 = Game.prototype.constructor;
        Game.prototype.constructor = function() {
            this.shaderManager = new ShaderManager(this);
            this.shaderManager.init();
            originalGameConstructor10.apply(this, arguments);
        };

        // Override material creation in MaterialPoolManager
        MaterialPoolManager.prototype.createMaterial = function(type) {
            if (this.materials.has(type)) return this.materials.get(type);
            
            try {
                const material = this.game.shaderManager.createMaterial(type);
                this.materials.set(type, material);
                return material;
            } catch (e) {
                console.warn(`Failed to create material for ${type}`, e);
                return null;
            }
        };

        // Add shader update to game loop
        const originalGameUpdate3 = Game.prototype.update;
        Game.prototype.update = function(timestamp) {
            if (this.shaderManager && OPTIMIZED_SHADERS.enabled) {
                this.shaderManager.updateLighting();
            }
            return originalGameUpdate3.call(this, timestamp);
        };

        // Add toggle method
        Game.prototype.toggleShaderOptimization = function(enabled) {
            OPTIMIZED_SHADERS.enabled = enabled;
            if (!enabled) {
                // Recreate all materials without optimized shaders
                this.materialPool.cleanup();
                this.materialPool.init();
            }
        };

        // Add memory management config
        const MEMORY_MANAGER = {
            enabled: true,
            initialized: false,
            defragInterval: 30000,    // Run every 30 seconds
            lastDefrag: Date.now(),
            gcThreshold: 100,         // Run GC after this many disposals
            disposalCount: 0,
            stats: {
                totalDisposed: 0,
                totalDefrag: 0,
                lastMemory: 0
            }
        };

        // Add MemoryManager class
        class MemoryManager {
            constructor(game) {
                this.game = game;
                this.initialized = false;
                this.disposedGeometries = new Set();
                this.disposedMaterials = new Set();
                this.disposedTextures = new Set();
                this.activeObjects = new WeakSet();
            }

            init() {
                if (this.initialized) return;
                try {
                    this.initialized = true;
                    MEMORY_MANAGER.initialized = true;
                    console.log('Memory manager initialized');
                    return true;
                } catch (e) {
                    console.warn('Memory manager failed to initialize', e);
                    this.initialized = false;
                    MEMORY_MANAGER.enabled = false;
                    return false;
                }
            }

            trackObject(object) {
                if (!MEMORY_MANAGER.enabled || !this.initialized) return;
                
                try {
                    this.activeObjects.add(object);
                    
                    // Track geometries
                    if (object.geometry) {
                        this.activeObjects.add(object.geometry);
                    }
                    
                    // Track materials
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(mat => this.activeObjects.add(mat));
                        } else {
                            this.activeObjects.add(object.material);
                        }
                    }
                    
                    // Track textures
                    if (object.material && object.material.map) {
                        this.activeObjects.add(object.material.map);
                    }
                } catch (e) {
                    console.warn('Failed to track object', e);
                }
            }

            disposeObject(object) {
                if (!MEMORY_MANAGER.enabled || !this.initialized) return;
                
                try {
                    // Dispose geometry
                    if (object.geometry) {
                        this.disposedGeometries.add(object.geometry);
                        object.geometry.dispose();
                    }
                    
                    // Dispose materials
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(mat => {
                                this.disposedMaterials.add(mat);
                                if (mat.map) {
                                    this.disposedTextures.add(mat.map);
                                    mat.map.dispose();
                                }
                                mat.dispose();
                            });
                        } else {
                            this.disposedMaterials.add(object.material);
                            if (object.material.map) {
                                this.disposedTextures.add(object.material.map);
                                object.material.map.dispose();
                            }
                            object.material.dispose();
                        }
                    }
                    
                    MEMORY_MANAGER.disposalCount++;
                    MEMORY_MANAGER.stats.totalDisposed++;
                    
                    // Check if we should run garbage collection
                    if (MEMORY_MANAGER.disposalCount >= MEMORY_MANAGER.gcThreshold) {
                        this.runGarbageCollection();
                        MEMORY_MANAGER.disposalCount = 0;
                    }
                } catch (e) {
                    console.warn('Failed to dispose object', e);
                }
            }

            defragment() {
                if (!MEMORY_MANAGER.enabled || !this.initialized) return;
                
                const now = Date.now();
                if (now - MEMORY_MANAGER.lastDefrag < MEMORY_MANAGER.defragInterval) {
                    return;
                }
                
                try {
                    // Clear disposed resources
                    this.disposedGeometries.clear();
                    this.disposedMaterials.clear();
                    this.disposedTextures.clear();
                    
                    // Force texture atlas rebuild if needed
                    if (TEXTURE_ATLAS.enabled && TEXTURE_ATLAS.atlas) {
                        TEXTURE_ATLAS.atlas.needsUpdate = true;
                    }
                    
                    // Update stats
                    MEMORY_MANAGER.lastDefrag = now;
                    MEMORY_MANAGER.stats.totalDefrag++;
                    MEMORY_MANAGER.stats.lastMemory = performance.memory ? 
                        performance.memory.usedJSHeapSize : 0;
                    
                    console.log('Memory defragmentation complete');
                } catch (e) {
                    console.warn('Defragmentation failed', e);
                }
            }

            runGarbageCollection() {
                if (window.gc) {
                    try {
                        window.gc();
                    } catch (e) {
                        console.warn('Manual GC failed', e);
                    }
                }
            }
        }

        // Modify Game class to use memory management
        const originalGameConstructor11 = Game.prototype.constructor;
        Game.prototype.constructor = function() {
            this.memoryManager = new MemoryManager(this);
            this.memoryManager.init();
            originalGameConstructor11.apply(this, arguments);
        };

        // Add memory management to chunk loading/unloading
        const originalLoadChunk2 = Game.prototype.loadChunk;
        Game.prototype.loadChunk = function(x, z, highPriority = false) {
            const chunk = originalLoadChunk2.call(this, x, z, highPriority);
            if (chunk && this.memoryManager) {
                this.memoryManager.trackObject(chunk);
            }
            return chunk;
        };

        const originalUnloadChunk = Game.prototype.unloadChunk;
        Game.prototype.unloadChunk = function(x, z) {
            const chunk = this.getChunk(x, z);
            if (chunk && this.memoryManager) {
                this.memoryManager.disposeObject(chunk);
            }
            return originalUnloadChunk.call(this, x, z);
        };

        // Add memory management to update loop
        const originalGameUpdate4 = Game.prototype.update;
        Game.prototype.update = function(timestamp) {
            if (this.memoryManager) {
                this.memoryManager.defragment();
            }
            return originalGameUpdate4.call(this, timestamp);
        };

        // Add toggle method
        Game.prototype.toggleMemoryManager = function(enabled) {
            MEMORY_MANAGER.enabled = enabled;
            if (!enabled) {
                this.memoryManager.disposedGeometries.clear();
                this.memoryManager.disposedMaterials.clear();
                this.memoryManager.disposedTextures.clear();
            }
        };

        // Add build presets functionality
        class BuildPresets {
            constructor(game) {
                this.game = game;
                this.setupKeyBindings();
            }

            setupKeyBindings() {
                document.addEventListener('keydown', (e) => {
                    const pos = this.game.player.position.clone();
                    switch(e.key) {
                        case '1': this.game.launchConstructionRocket(); break;
                        case '2': this.game.launchLargeConstructionRocket(); break;
                        case '3': this.game.launchMassiveConstructionRocket(); break;
                        case '4': this.game.launchRocket(); break;
                        case '5': this.game.launchTotalNuke(); break;
                        case '6': this.game.launchMassiveNuke(); break;
                        case '7': this.game.launchHouseConstructionRocket(); break;
                        case '8': this.game.launchOfficeConstructionRocket(); break;
                        case '9': this.game.launchSpaceXRocket(); break;
                    }
                });
            }

            // All the build preset methods from BuildPresets.js go here
            createTree(pos, size) {
                const height = size === 'large' ? 12 : 6;
                const trunkHeight = Math.floor(height * 0.6);
                const leafRadius = Math.floor(height * 0.4);

                // Create trunk
                for (let y = 0; y < trunkHeight; y++) {
                    this.setBlock(pos.x, pos.y + y, pos.z, 'oak_log');
                }

                // Create leaves in a natural pattern
                for (let x = -leafRadius; x <= leafRadius; x++) {
                    for (let y = 0; y < leafRadius * 2; y++) {
                        for (let z = -leafRadius; z <= leafRadius; z++) {
                            const distance = Math.sqrt(x*x + z*z);
                            if (distance <= leafRadius * (1 - y/(leafRadius * 2.5))) {
                                this.setBlock(
                                    pos.x + x,
                                    pos.y + trunkHeight + y,
                                    pos.z + z,
                                    'leaves'
                                );
                            }
                        }
                    }
                }
            }

            createRoad(pos, direction) {
                const length = 20;
                const width = 3;
                
                const startX = pos.x - (direction === 'EW' ? length/2 : width/2);
                const startZ = pos.z - (direction === 'NS' ? length/2 : width/2);
                
                // Create road surface
                for (let x = 0; x < (direction === 'EW' ? length : width); x++) {
                    for (let z = 0; z < (direction === 'NS' ? length : width); z++) {
                        this.setBlock(startX + x, pos.y - 1, startZ + z, 'stone');
                        // Add fences on the sides
                        if (direction === 'NS' && (z === 0 || z === length-1)) {
                            this.setBlock(startX + x, pos.y, startZ + z, 'fence');
                        } else if (direction === 'EW' && (x === 0 || x === length-1)) {
                            this.setBlock(startX + x, pos.y, startZ + z, 'fence');
                        }
                    }
                }
            }

            createGarden(pos) {
                const size = 10;
                // Create garden border
                for (let x = -size; x <= size; x++) {
                    for (let z = -size; z <= size; z++) {
                        if (Math.abs(x) === size || Math.abs(z) === size) {
                            this.setBlock(pos.x + x, pos.y - 1, pos.z + z, 'stone');
                            this.setBlock(pos.x + x, pos.y, pos.z + z, 'fence');
                        } else {
                            this.setBlock(pos.x + x, pos.y - 1, pos.z + z, 'dirt');
                            // Add random flowers and grass
                            if (Math.random() < 0.3) {
                                this.setBlock(pos.x + x, pos.y, pos.z + z, Math.random() < 0.5 ? 'flower' : 'tall_grass');
                            }
                        }
                    }
                }
            }

            createIslandscape(pos) {
                const size = 30;
                const waterLevel = pos.y - 5;
                
                for (let x = -size; x <= size; x++) {
                    for (let z = -size; z <= size; z++) {
                        // Generate island height using noise
                        const distance = Math.sqrt(x*x + z*z) / size;
                        const height = Math.floor((1 - distance) * 8 * Math.random());
                        
                        // Create deep water
                        for (let y = waterLevel - 3; y <= waterLevel; y++) {
                            this.setBlock(pos.x + x, y, pos.z + z, 'water');
                        }
                        
                        // Create islands
                        if (height > 0) {
                            for (let y = waterLevel - 3; y <= waterLevel + height; y++) {
                                const block = y === waterLevel + height ? 'grass' : 'dirt';
                                this.setBlock(pos.x + x, y, pos.z + z, block);
                            }
                        }
                    }
                }
            }

            createPalace(pos) {
                const size = 15;
                const height = 20;
                
                // Create main structure
                for (let x = -size; x <= size; x++) {
                    for (let z = -size; z <= size; z++) {
                        for (let y = 0; y < height; y++) {
                            // Create walls
                            if (Math.abs(x) === size || Math.abs(z) === size || y === 0 || y === height-1) {
                                this.setBlock(pos.x + x, pos.y + y, pos.z + z, 'quartz');
                            }
                            // Add decorative gold trim
                            if ((y % 5 === 0) && (Math.abs(x) === size || Math.abs(z) === size)) {
                                this.setBlock(pos.x + x, pos.y + y, pos.z + z, 'gold');
                            }
                        }
                    }
                }
                
                // Add towers at corners
                const towerPositions = [
                    [size, size], [-size, size], [size, -size], [-size, -size]
                ];
                towerPositions.forEach(([x, z]) => {
                    for (let y = 0; y < height + 10; y++) {
                        for (let dx = -2; dx <= 2; dx++) {
                            for (let dz = -2; dz <= 2; dz++) {
                                if (Math.abs(dx) === 2 || Math.abs(dz) === 2) {
                                    this.setBlock(pos.x + x + dx, pos.y + y, pos.z + z + dz, 'quartz');
                                }
                            }
                        }
                    }
                });
            }

            createMaze(pos) {
                const size = 15;
                const height = 3;
                const maze = this.generateMaze(size);
                
                // Create maze walls
                for (let x = 0; x < size * 2 + 1; x++) {
                    for (let z = 0; z < size * 2 + 1; z++) {
                        if (maze[x][z] === 1) {
                            for (let y = 0; y < height; y++) {
                                this.setBlock(pos.x + x - size, pos.y + y, pos.z + z - size, 'stone');
                            }
                        }
                    }
                }
            }

            generateMaze(size) {
                const maze = Array(size * 2 + 1).fill().map(() => Array(size * 2 + 1).fill(1));
                const stack = [[1, 1]];
                maze[1][1] = 0;
                
                while (stack.length > 0) {
                    const [x, z] = stack[stack.length - 1];
                    const directions = [
                        [0, 2], [2, 0], [0, -2], [-2, 0]
                    ].sort(() => Math.random() - 0.5);
                    
                    let moved = false;
                    for (const [dx, dz] of directions) {
                        const nx = x + dx, nz = z + dz;
                        if (nx > 0 && nx < size * 2 && nz > 0 && nz < size * 2 && maze[nx][nz] === 1) {
                            maze[x + dx/2][z + dz/2] = 0;
                            maze[nx][nz] = 0;
                            stack.push([nx, nz]);
                            moved = true;
                            break;
                        }
                    }
                    if (!moved) stack.pop();
                }
                return maze;
            }

            createSpaceX(pos) {
                const rocketHeight = 30;
                const baseRadius = 2;
                
                // Create launch pad
                for (let x = -10; x <= 10; x++) {
                    for (let z = -10; z <= 10; z++) {
                        this.setBlock(pos.x + x, pos.y - 1, pos.z + z, 'metal');
                        if (Math.abs(x) === 10 || Math.abs(z) === 10) {
                            this.setBlock(pos.x + x, pos.y, pos.z + z, 'fence');
                        }
                    }
                }
                
                // Create rocket body
                for (let y = 0; y < rocketHeight; y++) {
                    const radius = y < rocketHeight - 5 ? baseRadius : 
                                 baseRadius - (y - (rocketHeight - 5)) * 0.4;
                    
                    for (let x = -Math.ceil(radius); x <= Math.ceil(radius); x++) {
                        for (let z = -Math.ceil(radius); z <= Math.ceil(radius); z++) {
                            if (x*x + z*z <= radius*radius) {
                                this.setBlock(pos.x + x, pos.y + y, pos.z + z, 'metal');
                            }
                        }
                    }
                }
                
                // Add fins
                const finPositions = [[1,0], [-1,0], [0,1], [0,-1]];
                finPositions.forEach(([x, z]) => {
                    for (let y = 0; y < 5; y++) {
                        this.setBlock(pos.x + x * (baseRadius + 1), pos.y + y, pos.z + z * (baseRadius + 1), 'metal');
                    }
                });
            }

            // ... existing setBlock method ...
            setBlock(x, y, z, type) {
                const chunk = this.game.world.getChunkAtPosition(new THREE.Vector3(x, y, z));
                if (chunk) {
                    chunk.setBlock(new THREE.Vector3(x, y, z), type);
                    chunk.isDirty = true;
                }
            }
        }

        // Initialize build presets when game starts
        game.buildPresets = new BuildPresets(game);
    </script>
</body>
</html> 